%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{dfnWorks Documentation}
\date{Jun 10, 2019}
\release{2.2}
\author{Subsurface Flow and Transport Team 
 LANL 
 LA-UR-17-22216}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{dfnworks_logo.png}\par}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\maketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index_docs::doc}}


Contents:


\chapter{Introduction}
\label{\detokenize{intro:introduction}}\label{\detokenize{intro::doc}}
dfnWorks is a parallelized computational suite to generate three-dimensional
discrete fracture networks (DFN) and simulate flow and transport. Developed at
Los Alamos National Laboratory, it has been used to study flow and transport
in fractured media at scales ranging from millimeters to kilometers. The
networks are created and meshed using dfnGen, which combines FRAM (the feature
rejection algorithm for meshing) methodology to stochastically generate
three-dimensional DFNs with the LaGriT meshing toolbox to create a high-quality
computational mesh representation. The representation produces a conforming
Delaunay triangulation suitable for high performance computing finite volume
solvers in an intrinsically parallel fashion. Flow through the network is
simulated with dfnFlow, which utilizes the massively parallel subsurface flow
and reactive transport finite volume code PFLOTRAN. A Lagrangian approach to
simulating transport through the DFN is adopted within dfnTrans to determine
pathlines and solute transport through the DFN. Applications of the dfnWorks
suite include nuclear waste repository science, hydraulic fracturing and
CO$_{\text{2}}$ sequestration.

To run a workflow using the dfnWorks suite, the pydfnworks package is
highly recommended. pydfnworks calls various tools in the dfnWorks suite with
the aim to provide a seamless workflow for scientific applications of dfnWorks.


\section{Citing dfnWorks}
\label{\detokenize{intro:citing-dfnworks}}
\sphinxhref{http://www.sciencedirect.com/science/article/pii/S0098300415300261/}{Hyman, J. D., Karra, S., Makedonska, N., Gable, C. W., Painter, S. L., \&
Viswanathan, H. S. (2015). dfnWorks: A discrete fracture network framework
for modeling subsurface flow and transport. Computers \& Geosciences, 84,
10-19.}

\sphinxstyleemphasis{BibTex:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  @article\PYGZob{}hyman2015dfnWorks,
    title=\PYGZob{}dfnWorks: A discrete fracture network framework
for modeling subsurface flow and transport\PYGZcb{},
    author=\PYGZob{}Hyman, Jeffrey D and Karra, Satish and Makedonska,
Nataliia and Gable, Carl W and Painter, Scott L
and Viswanathan, Hari S\PYGZcb{},
    journal=\PYGZob{}Computers \PYGZbs{}\PYGZam{} Geosciences\PYGZcb{},
    volume=\PYGZob{}84\PYGZcb{},
    pages=\PYGZob{}10\PYGZhy{}\PYGZhy{}19\PYGZcb{},
    year=\PYGZob{}2015\PYGZcb{},
    publisher=\PYGZob{}Elsevier\PYGZcb{}
  \PYGZcb{}
\end{sphinxVerbatim}


\section{What’s new in v2.2?}
\label{\detokenize{intro:what-s-new-in-v2-2}}\begin{itemize}
\item {} 
pydfnWorks updated for python3

\item {} 
Graph based (pipe-network approximations) for flow and transport

\item {} 
Bug fixes in LaGrit Meshing

\item {} 
Increased functionalities in pydfnworks including the path option

\item {} 
dfn2graph capabilities

\item {} 
FEHM flow solver

\item {} 
Streamline routing option in dfnTrans

\item {} 
Time Domain Random Walk in dfnTrans

\end{itemize}


\section{What’s new in v2.1?}
\label{\detokenize{intro:what-s-new-in-v2-1}}\begin{itemize}
\item {} 
Bug fixes in LaGrit Meshing

\item {} 
Increased functionalities in pydfnworks including the path option

\end{itemize}


\section{What’s new in v2.0?}
\label{\detokenize{intro:what-s-new-in-v2-0}}\begin{itemize}
\item {} 
New dfnGen C++ code which is much faster than the Mathematica dfnGen. This code has successfully generated networks with 350,000+ fractures.

\item {} 
Increased functionality in the pydfnworks package for more streamlined workflow from dfnGen through visualization.

\end{itemize}


\section{Where can one get dfnWorks?}
\label{\detokenize{intro:where-can-one-get-dfnworks}}
dfnWorks 2.2 can be downloaded from \sphinxurl{https://github.com/lanl/dfnWorks/}

v1.0 can be downloaded from \sphinxurl{https://github.com/dfnWorks/dfnWorks-Version1.0}


\section{Installation}
\label{\detokenize{intro:installation}}
Tools that you will need to run the dfnWorks work flow are described in
this section. VisIt and ParaView, which enable visualization of desired
quantities on the DFNs, are optional, but at least one of them is highly
recommended for visualization. CMake is also optional but allows faster IO
processing using C++.


\subsection{Operating Systems}
\label{\detokenize{intro:operating-systems}}
dfnWorks currently runs on Macs and Unix machine running Ubuntu.


\subsection{Python}
\label{\detokenize{intro:python}}
pydfnworks is supported on Python 3. The software authors recommend using
the Anaconda 3 distribution of Python, available at \sphinxurl{https://www.continuum.io/}.
pydfnworks requires the following python modules: \sphinxcode{\sphinxupquote{numpy}}, \sphinxcode{\sphinxupquote{h5py}}, \sphinxcode{\sphinxupquote{scipy}}, \sphinxcode{\sphinxupquote{matplotlib}},  \sphinxcode{\sphinxupquote{multiprocessing}}, \sphinxcode{\sphinxupquote{argparse}}, \sphinxcode{\sphinxupquote{shutil}}, \sphinxcode{\sphinxupquote{os}}, \sphinxcode{\sphinxupquote{sys}}, \sphinxcode{\sphinxupquote{networkx}}, \sphinxcode{\sphinxupquote{subprocess}}, \sphinxcode{\sphinxupquote{glob}}, and \sphinxcode{\sphinxupquote{re}}.


\subsection{pydfnworks}
\label{\detokenize{intro:pydfnworks}}
The source for pydfnworks can be found in the dfnWorks suite, in the folder
pydfnworks.


\subsection{dfnGen}
\label{\detokenize{intro:dfngen}}
dfnGen primarily involves two steps: FRAM (the feature rejection algorithm for meshing) and LaGriT, the meshing tool box used to create a conforming Delaunay triangulation of the network.


\subsubsection{FRAM}
\label{\detokenize{intro:fram}}
FRAM (the feature rejection algorithm for meshing) is executed using the
dfnGen C++ source code, contained in the dfnGen folder of the dfnWorks repository.


\subsubsection{LaGriT}
\label{\detokenize{intro:lagrit}}
The \sphinxhref{https://lagrit.lanl.gov}{LaGriT} meshing toolbox is used to create a high resolution computational
mesh representation of the DFN in parallel. An algorithm for conforming
Delaunay triangulation is implemented so that fracture intersections are
coincident with triangle edges in the mesh and Voronoi control volumes are
suitable for finite volume flow solvers such as FEHM and PFLOTRAN.


\subsection{dfnFlow}
\label{\detokenize{intro:dfnflow}}
You will need one of either PFLOTRAN or FEHM to solve for flow using the
mesh files from LaGriT.


\subsubsection{PFLOTRAN}
\label{\detokenize{intro:pflotran}}
\sphinxhref{http://pflotran.org}{PFLOTRAN}  is a massively parallel subsurface flow and reactive transport
code. PFLOTRAN solves a system of partial differential equations for
multiphase, multicomponent and multiscale reactive flow and transport in
porous media. The code is designed to run on leadership-class supercomputers
as well as workstations and laptops.


\subsubsection{FEHM}
\label{\detokenize{intro:fehm}}
\sphinxhref{https://fehm.lanl.gov}{FEHM} is a subsurface multiphase flow code developed at Los Alamos National
Laboratory.


\subsection{dfnTrans}
\label{\detokenize{intro:dfntrans}}
dfnTrans is a method for resolving solute transport using control volume flow
solutions obtained from dfnFlow on the unstructured mesh generated using
dfnGen. We adopt a Lagrangian approach and represent a non-reactive
conservative solute as a collection of indivisible passive tracer particles.


\subsection{dfnGraph}
\label{\detokenize{intro:dfngraph}}
dfnGraph is a suite of graph-based methods for use with DFN generated using
dfnWorks DFN. This suite includes multiple methods to prune a DFN and simulate
flow and transport in pipe-networks derived from a DFN. dfnGraph uses the
\sphinxhref{https://networkx.github.io/}{networkX} python software to handle graph representations.


\subsection{CMake}
\label{\detokenize{intro:cmake}}
\sphinxhref{https://cmake.org}{CMake} is an open-source, cross-platform family of tools designed to build,
test and package software. It is needed to use C++ for processing files at a
bottleneck IO step of dfnWorks. Using C++ for this file processing optional
but can greatly increase the speed of dfnWorks for large fracture networks.
Details on how to use C++ for file processing are in the scripts section of
this documentation.


\subsection{Paraview}
\label{\detokenize{intro:paraview}}
\sphinxhref{http://www.paraview.org}{Paraview} is a parallel, open-source visualisation software. PFLOTRAN can
output in \sphinxcode{\sphinxupquote{.xmf}} and \sphinxcode{\sphinxupquote{.vtk}} format. These can be imported in Paraview
for visualization.

Instructions for downloading and installing \sphinxhref{http://www.paraview.org}{Paraview} can be found at
\sphinxurl{http://www.paraview.org/download/}


\section{Using pydfnworks in your Python scripts}
\label{\detokenize{intro:using-pydfnworks-in-your-python-scripts}}
To access the functionality of pydfnworks, the user must include the
following line at the
top of any Python script

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pydfnworks}
\end{sphinxVerbatim}

Before doing this, one needs to ensure that the pydfnworks directory is in the
PYTHONPATH. This can be done by configuring \sphinxcode{\sphinxupquote{cshrc}} or \sphinxcode{\sphinxupquote{bashrc}} files.
Alternatively, one can add the pydfnworks path using \sphinxcode{\sphinxupquote{sys.path.append()}}
in their driver script.


\section{About this  manual}
\label{\detokenize{intro:about-this-manual}}
This manual comprises of information on setting up inputs to dfnGen, dfnTrans
and PFLOTRAN, as well as details on the pydfnworks module: {\hyperref[\detokenize{pydfnworks:dfnworks-python-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{pydfnworks}}}}. Finally, the manual contains a short tutorial
with prepared examples that  can be found in the \sphinxcode{\sphinxupquote{tests}} directory of the
dfnWorks repository, and a description of some applications of the dfnWorks
suite.


\section{Contributors}
\label{\detokenize{intro:contributors}}\begin{itemize}
\item {} 
Jeffrey Hyman

\item {} 
Satish Karra

\item {} 
Nataliia Makedonska

\item {} 
Carl Gable

\item {} 
Hari Viswanathan

\item {} 
Matt Sweeney

\item {} 
Shriram Srinivasan

\item {} 
Quan Bui (now at LLNL)

\item {} 
Jeremy Harrod (now at Spectra Logic)

\item {} 
Scott Painter (now at ORNL)

\item {} 
Thomas Sherman (University of Notre Dame)

\end{itemize}


\section{Contact}
\label{\detokenize{intro:contact}}
For any questions about dfnWorks, please email \sphinxhref{mailto:dfnworks@lanl.gov}{dfnworks@lanl.gov}.


\section{Copyright information}
\label{\detokenize{intro:copyright-information}}
Documentation:

LA-UR-17-22216

Software copyright:

LA-CC-17-02


\bigskip\hrule\bigskip


LA-CC-17-027

(or copyright) 2018 Triad National Security, LLC. All rights reserved.
\begin{description}
\item[{This program was produced under U.S. Government contract 89233218CNA000001}] \leavevmode
for Los Alamos National Laboratory (LANL), which is operated by Triad
National Security, LLC for the U.S. Department of Energy/National Nuclear
\begin{quote}

Security Administration.
\end{quote}

\end{description}

All rights in the program are reserved by Triad National Security, LLC,
and the U.S. Department of Energy/National Nuclear Security Administration.
\begin{quote}

The Government is granted for itself and others acting on its behalf a
nonexclusive, paid-up, irrevocable worldwide license in this material
to reproduce, prepare derivative works, distribute copies to the public,
\begin{quote}

perform publicly and display publicly, and to permit others to do so.
\end{quote}

The U.S. Government has rights to use, reproduce, and distribute this software.
NEITHER THE GOVERNMENT NOR TRIAD NATIONAL SECURITY, LLC MAKES ANY WARRANTY,
EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE.
If software is modified to  produce derivative works, such modified
software should be clearly marked, so as not to confuse it with the
version available from LANL.
\end{quote}

Additionally, this program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your option)
any later version. Accordingly, this program is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
License for more details.

Additionally, redistribution and use in source and binary forms, with or
without modification, are permitted provided that the following conditions are
met:
1.       Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2.      Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

3.      Neither the name of Los Alamos National Security, LLC, Los Alamos
National Laboratory, LANL, the U.S. Government, nor the names of its
contributors may be used to endorse or promote products derived from this
software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND
CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL
SECURITY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

Additionally, this program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at your
option) any later version. Accordingly, this program is distributed in the
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.


\chapter{Setting up dfnWorks}
\label{\detokenize{setup:setting-up-dfnworks}}\label{\detokenize{setup::doc}}
This document contains instructions for setting up dfnWorks natively on your
machine. To setup dfnWorks using Docker instead, see the next section.


\section{Turn on X forwarding if on server}
\label{\detokenize{setup:turn-on-x-forwarding-if-on-server}}
Ensure that X forwarding is turned on if you are running dfnWorks from an ssh connection. This requires that the ssh login have the -X option:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ssh \PYGZhy{}X SERVER\PYGZus{}NAME
\end{sphinxVerbatim}


\section{Go to the dnfWorks repository}
\label{\detokenize{setup:go-to-the-dnfworks-repository}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} \PYGZti{}/dfnWorks/
\end{sphinxVerbatim}


\section{Fix paths in test directory}
\label{\detokenize{setup:fix-paths-in-test-directory}}
Fix the pathnames for all files in the folder \sphinxcode{\sphinxupquote{/tests/}} . This can be done automatically by running the script \sphinxcode{\sphinxupquote{fix\_paths.py}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} /pydfnworks/bin/
\PYGZdl{} python fix\PYGZus{}paths.py
\end{sphinxVerbatim}


\section{Set the PETSC, PFLOTRAN, Python, and LaGriT paths}
\label{\detokenize{setup:set-the-petsc-pflotran-python-and-lagrit-paths}}
\sphinxstylestrong{Before executing dfnWorks,} the following paths must be set:
\begin{itemize}
\item {} 
dfnWorks\_PATH: the dfnWorks repository folder

\item {} 
PETSC\_DIR and PETSC\_ARCH: PETSC environmental variables

\item {} 
PFLOTRAN\_EXE:  Path to PFLOTRAN executable

\item {} 
PYTHON\_EXE:  Path to python executable

\item {} 
LAGRIT\_EXE:  Path to LaGriT executable

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} vi /pydfnworks/pydfnworks/paths.py
\end{sphinxVerbatim}

For example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{os}\PYG{o}{.}\PYG{n}{environ}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dfnWorks\PYGZus{}PATH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/home/username/dfnWorks/}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}


\section{Setup the Python package pydfnworks}
\label{\detokenize{setup:setup-the-python-package-pydfnworks}}
Go up a directory:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} ..
\end{sphinxVerbatim}

\sphinxstylestrong{If the user has admin privelges}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python setup.py install
\end{sphinxVerbatim}

\sphinxstylestrong{If the user DOES NOT have admin priveleges}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python setup.py install \PYGZhy{}\PYGZhy{}user
\end{sphinxVerbatim}


\chapter{Running dfnWorks from Docker}
\label{\detokenize{setup:running-dfnworks-from-docker}}
If you do not already have Docker installed on your machine,
visit \sphinxhref{https://www.docker.com/get-started}{Getting Started with Docker}.

The dfnWorks Docker image can be pulled from DockerHub using:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} docker pull ees16/dfnworks
\end{sphinxVerbatim}


\section{Setting Up X-Forwarding}
\label{\detokenize{setup:setting-up-x-forwarding}}
\sphinxstylestrong{On macOS:}

To setup X-forwarding on macOS, you will need \sphinxcode{\sphinxupquote{socat}} and \sphinxcode{\sphinxupquote{xquartz}}.
To install, run:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
brew install socat
brew cask install xquartz
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{socat}} is used to expose the local XQuartz socker over a TCP port, enabling the
Docker container to exchange display information with your local machine.

\sphinxstylestrong{On Linux:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TODO
\end{sphinxVerbatim}


\section{Running the dfnWorks container}
\label{\detokenize{setup:running-the-dfnworks-container}}
The base command for running the dfnWorks container is:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
docker run \PYGZhy{}ti dfnworks:latest
\end{sphinxVerbatim}

However, to exchange files between the host and container, we will need to mount
a volume.

The option \sphinxcode{\sphinxupquote{-v LOCAL\_FOLDER:/dfnWorks/work}} will allow all files present in the
container folder \sphinxcode{\sphinxupquote{dfnWorks/work}} to be exposed to \sphinxcode{\sphinxupquote{LOCAL\_FOLDER}}, where
\sphinxcode{\sphinxupquote{LOCAL\_FOLDER}} is the absolute path to a folder on your machine.

In order to exchange display information, we will need to pass in the DISPLAY
variable from host to container.

On macOS, this is \sphinxcode{\sphinxupquote{-e DISPLAY=docker.for.mac.host.internal:0}}. On Linux, it is
\sphinxcode{\sphinxupquote{TODO}}.

With this is place, the final command for running the Docker container is:

\sphinxstylestrong{On macOS:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
open \PYGZhy{}a XQuartz
socat TCP\PYGZhy{}LISTEN:6000,reuseaddr,fork UNIX\PYGZhy{}CLIENT:\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}DISPLAY}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}
docker run \PYGZhy{}ti \PYG{l+s+se}{\PYGZbs{}}
       \PYGZhy{}e \PYG{n+nv}{DISPLAY}\PYG{o}{=}docker.for.mac.host.internal:0 \PYG{l+s+se}{\PYGZbs{}}
       \PYGZhy{}v /Users/yourname/dfnworks\PYGZhy{}example:/dfnWorks/work \PYG{l+s+se}{\PYGZbs{}}
       dfnworks:latest
\end{sphinxVerbatim}

\sphinxstylestrong{On Linux:}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TODO
\end{sphinxVerbatim}


\section{Troubleshooting}
\label{\detokenize{setup:troubleshooting}}
If you recieve a warning that port 6000 is in use, run either \sphinxcode{\sphinxupquote{lsof -i TCP:6000}}
or \sphinxcode{\sphinxupquote{netstat -vanp tcp \textbar{} grep 6000}} to isolate the process listening on this port.

Then, use \sphinxcode{\sphinxupquote{kill -i \textless{}PID\textgreater{}}} to kill the process and re-run \sphinxcode{\sphinxupquote{xquartz}}, \sphinxcode{\sphinxupquote{socat}},
and \sphinxcode{\sphinxupquote{docker run}}.


\chapter{Examples}
\label{\detokenize{examples:examples}}\label{\detokenize{examples::doc}}
This document contains examples for using dfnWorks. All required input files for these examples are contained in the folder dfnWorks/examples/. The focus of this document is to provide visual confirmation that new users of dfnWorks have the code set up correctly, can carry out the following runs and reproduce the following images. All images are rendered using Paraview, which can be obtained for free at http : //www.paraview.org/. The first two examples are simplest so it is recommended that the user proceed in the order presented here.

All examples are in the examples/ directory. Within each subdirectory are the files required to run the example. The command line input is found in notes.txt. Be sure that you have created \textasciitilde{}/test\_output\_files prior to running the examples.


\section{4\_user\_defined\_rects}
\label{\detokenize{examples:user-defined-rects}}
Location: examples/4\_user\_defined\_rects/

This test case consists of four user defined rectangular fractures within a a cubic domain with sides of length one meter. The network of four fractures, each colored by material ID. The computational mesh is overlaid on the fractures. This image is created by loading the file full\_mesh.inp. located in the job folder into Paraview.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{4_user_rectangles_mesh}.png}
\caption{\sphinxstyleemphasis{The meshed network of four rectangular fractures.}}\label{\detokenize{examples:id1}}\end{figure}

High pressure (red) Dirichlet boundary conditions are applied on the edge of the single fracture along the boundary x = -0.5, and low pressure (blue) boundary conditions are applied on the edges of the two fractures at the boundary x = 0.5.
This image is created by loading the file parsed\_vtk/dfn\_explicit-001.vtk into Paraview.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{4_user_rectangles_pressure}.png}
\caption{\sphinxstyleemphasis{The network of four fractures, colored by pressure solution.}}\label{\detokenize{examples:id2}}\end{figure}

Particles are inserted uniformly along the inlet fracture on the left side of the image.
Particles exit the domain through the two horizontal fractures on the right side of the image.
Due to the stochastic nature of the particle tracking algorithm, your pathlines might not be exactly the same as in this image.
Trajectories are colored by the current velocity magnitude of the particle’s velocity.
Trajectories can be visualized by loading the files part\_*.inp, in the folder 4\_user\_rectangles/traj/trajectories/
We have used the extract surface and tube filters in paraview for visual clarity.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.08]{{4_user_rectangles_trace}.png}
\caption{\sphinxstyleemphasis{Particle trajectories on the network of four fractures.}}\label{\detokenize{examples:id3}}\end{figure}


\section{4\_user\_defined\_ell\_uniform}
\label{\detokenize{examples:user-defined-ell-uniform}}
Location: examples/4\_user\_defined\_ell\_uniform/

This test case consists of four user defined elliptical fractures within a a cubic domain with sides of length one meter. In this case the ellipses are approximated using 8 vertices. We have set the meshing resolution to be uniform by including the argument slope=0 into the mesh\_networks function in run\_explicit.py.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{4_user_ellipses_mesh}.png}
\caption{\sphinxstyleemphasis{The uniformly meshed network of four circular fractures.}}\label{\detokenize{examples:id4}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{4_user_ellipses_pressure}.png}
\caption{\sphinxstyleemphasis{The network of four circular fractures, colored by pressure solution. Contours in the pressure are shown as black lines.}}\label{\detokenize{examples:id5}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{4_user_ellipses_trace}.png}
\caption{\sphinxstyleemphasis{Particle trajectories on the network of four circular fractures.}}\label{\detokenize{examples:id6}}\end{figure}


\section{exp: Exponentially Distributed fracture lengths}
\label{\detokenize{examples:exp-exponentially-distributed-fracture-lengths}}
Location: examples/exp/

This test case consists of a family of fractures whose size is exponentially distributed with a minimum size of 1m and a maximum size of 50m. The domain is cubic with an edge length of 10m. All input parameters for the generator can be found in tests/gen\_exponential\_dist.dat.  We have changed the flow direction to be aligned with the y-axis by modifying the PFLOTRAN input card dfn\_explicit.in

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{exp_mesh}.png}
\caption{\sphinxstyleemphasis{Network with rectangular fractures whose lengths following a exponential distribution.}}\label{\detokenize{examples:id7}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{exp_pressure}.png}
\caption{\sphinxstyleemphasis{Pressure solution on with rectangular fractures whose lengths following a exponential distribution. Gradient is aligned with the Y-Axis}}\label{\detokenize{examples:id8}}\end{figure}


\section{lognormal}
\label{\detokenize{examples:lognormal}}
Location: examples/lognormal/

This test case consists of two fracture families whose sizes have a lognormal distribution with a minimum size of 0.5m and a maximum size of 50m. The domain size is cubic with an edge length of 10m. All input parameters for the generator can be found in tests/gen\_lognormal\_dist.dat. We have changed the flow direction to be aligned with the z-axis by modifying the PFLOTRAN input card dfn\_explicit.in

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.3]{{lognormal_mesh}.png}
\end{figure}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.3]{{lognormal_pressure}.png}
\end{figure}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}


\section{TPL: Truncated Power Law}
\label{\detokenize{examples:tpl-truncated-power-law}}
Location: examples/TPL/

This test case consists of two families whose sizes have a truncated power law distribution with a minimum size of 1m and a maximum size of 5m an exponent 2.6. The domain size is cubic with an edge length of 15m.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.3]{{power_mesh}.png}
\end{figure}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.3]{{power_pressure}.png}
\end{figure}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.3]{{power_trace}.png}
\end{figure}


\section{Graph based pruning}
\label{\detokenize{examples:graph-based-pruning}}
Location: examples/pruning/

This example uses a graph representation of a DFN to isolate the 2-core. The pruned DFN has all dead end fractures of the network are removed. This example has two run\_explicit.py scripts. The first creates the original DFN and identifies the 2-core using networkx (\sphinxurl{https://networkx.github.io/}). The second meshes the DFN corresponding to the 2-core of the graph and then runs flow and transport. The 2 core network is in a sub-directory 2-core. The original network has 207 fractures and the 2-core has 79 fractures.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.3]{{dfn_2_core}.png}
\caption{\sphinxstyleemphasis{(left) Graph based on DFN topology. Each vertex is a fracture in the network. The inflow boundary is colored blue and the outflow is colored red. (right) 2-Core of the graph to the left.}}\label{\detokenize{examples:id9}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.05]{{pruned_network}.png}
\caption{\sphinxstyleemphasis{(left) Original DFN (right) DFN corresponding to the 2-core of the DFN to the left.}}\label{\detokenize{examples:id10}}\end{figure}


\section{In Fracture Variability}
\label{\detokenize{examples:in-fracture-variability}}
Location: examples/in\_fracture\_var/

This example runs the four rectangular fracture case with variable fracture aperture in each plane. The aperture field is modeled as a correlated multi-variant Gaussian random field. The aperture values are in the aper\_node.dat file and the permeabilities are in perm\_node.dat. The command line argument indicating that there is spatially variable aperture field is -cell.  In fracture variability is not supported for FEHM runs at this time.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{in_fracture_var_perm}.png}
\caption{\sphinxstyleemphasis{The meshed network of four rectangular fractures colored by permeability, which is spatially variable on each fracture.}}\label{\detokenize{examples:id11}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{in_fracture_var_pressure}.png}
\caption{\sphinxstyleemphasis{The network of four fractures, colored by pressure solution. Black lines are contours in the pressure field.}}\label{\detokenize{examples:id12}}\end{figure}


\chapter{Example Applications}
\label{\detokenize{applications:example-applications}}\label{\detokenize{applications::doc}}

\section{Carbon dioxide sequestration}
\label{\detokenize{applications:carbon-dioxide-sequestration}}
dfnWorks provides the framework necessary to perform multiphase simulations (such as flow and reactive transport) at the reservoir scale. A particular application, highlighted here, is sequestering CO$_{\text{2}}$  from anthropogenic sources and disposing it in geological formations such as deep saline aquifers and abandoned oil fields. Geological CO$_{\text{2}}$  sequestration is one of the principal methods under consideration to reduce carbon footprint in the atmosphere due to fossil fuels (Bachu, 2002; Pacala and Socolow, 2004). For safe and sustainable long-term storage of CO$_{\text{2}}$  and to prevent leaks through existing faults and fractured rock (along with the ones created during the injection process), understanding the complex physical and chemical interactions between CO$_{\text{2}}$ , water (or brine) and fractured rock, is vital. dfnWorks capability to study multiphase flow in a DFN can be used to study potential CO$_{\text{2}}$  migration through cap-rock, a potential risk associated with proposed subsurface storage of CO$_{\text{2}}$  in saline aquifers or depleted reservoirs. Moreover, using the reactive transport capabilities of PFLOTRAN coupled with cell-based transmissivity of the DFN allows one to study dynamically changing permeability fields with mineral precipitation and dissolution due to CO$_{\text{2}}$ \textendash{}water interaction with rock.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{time_co2}.png}
\caption{\sphinxstyleemphasis{Temporal evolution of supercritical \textbar{}CO2\textbar{}  displacing water in a meter cube DFN containing 24 fractures. The DFN is initially fully saturated with water, (top left time 0 hours) and supercritical \textbar{}CO2\textbar{}  is slowly injected into the system from the bottom of the domain to displace the water for a total time of 10 h. There is an initial flush through the system during the first hour of the simulation, and then the rate of displacement decreases.}}\label{\detokenize{applications:id1}}\end{figure}


\section{Shale energy extraction}
\label{\detokenize{applications:shale-energy-extraction}}
Hydraulic fracturing (fracking) has provided access to hydrocarbon trapped in low-permeability media, such as tight shales. The process involves injecting water at high pressures to reactivate existing fractures and also create new fractures to increase permeability of the shale allowing hydrocarbons to be extracted. However, the fundamental physics of why fracking works and its long term ramifications are not well understood. Karra et al. (2015) used dfnWorks to generate a typical production site and simulate production. Using this physics based model, they found good agreement with production field data and determined what physical mechanisms control the decline in the production curve.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{well-pressure}.png}
\caption{\sphinxstyleemphasis{Pressure in a well used for hydraulic fracturing.}}\label{\detokenize{applications:id2}}\end{figure}


\section{Nuclear waste repository}
\label{\detokenize{applications:nuclear-waste-repository}}
The Swedish Nuclear Fuel and Waste Management Company (SKB) has undertaken a detailed investigation of the fractured granite at the Forsmark, Sweden site as a potential host formation for a subsurface repository for spent nuclear fuel (SKB, 2011; Hartley and Joyce, 2013). The Forsmark area is about 120 km north of Stockholm in northern Uppland, and the repository is proposed
to be constructed in crystalline bedrock at a depth of approximately 500 m. Based on the SKB site investigation, a statistical fracture model with multiple fracture sets was developed; detailed parameters of the Forsmark site model are in SKB (2011). We adopt a subset of the model that consist of three sets of background (non-deterministic) circular fractures whose orientations follow a Fisher distribution, fracture radii are sampled from a truncated power-law distribution, the transmissivity of the fractures is estimated using a power-law model based on the fracture radius, and the fracture aperture is related to the fracture size using the cubic law (Adler et al., 2012). Under such a formulation, the fracture apertures are uniform on each fracture, but vary among fractures. The network is generated in a cubic domain with sides of length one-kilometer. Dirichlet boundary conditions are imposed on the top (1 MPa) and bottom (2 MPa) of the domain to create a pressure gradient aligned with the vertical axis, and noflow boundary conditions are enforced along lateral boundaries.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.1]{{forsmark_trajectories}.png}
\caption{\sphinxstyleemphasis{Simulated particle trajectories in fractured granite at Forsmark, Sweden.}}\label{\detokenize{applications:id3}}\end{figure}

Sources:
\begin{itemize}
\item {} 
Adler, P.M., Thovert, J.-F., Mourzenko, V.V., 2012. Fractured Porous Media. Oxford University Press, Oxford, United Kingdom.

\item {} 
Bachu, S., 2002. Sequestration of CO$_{\text{2}}$  in geological media in response to climate change: road map for site selection using the transform of the geological space into the CO$_{\text{2}}$  phase space. Energy Convers. Manag. 43, 87\textendash{}102.

\item {} 
Hartley, L., Joyce, S., 2013. Approaches and algorithms for groundwater flow modeling in support of site investigations and safety assessment of the Fors- mark site, Sweden. J. Hydrol. 500, 200\textendash{}216.

\item {} 
Karra, S., Makedonska, N., Viswanathan, H., Painter, S., Hyman, J., 2015. Effect of advective flow in fractures and matrix diffusion on natural gas production. Water Resour. Res., under review.

\item {} 
Pacala, S., Socolow, R., 2004. Stabilization wedges: solving the climate problem for the next 50 years with current technologies. Science 305, 968\textendash{}972.

\item {} 
SKB, Long-Term Safety for the Final Repository for Spent Nuclear Fuel at Forsmark. Main Report of the SR-Site Project. Technical Report SKB TR-11-01, Swedish Nuclear Fuel and Waste Management Co., Stockholm, Sweden, 2011.

\end{itemize}


\chapter{dfnWorks Publications}
\label{\detokenize{publications:dfnworks-publications}}\label{\detokenize{publications:publications-chapter}}\label{\detokenize{publications::doc}}
The following are publications that use \sphinxstyleemphasis{dfnWorks}:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
J. D. Hyman, C. W. Gable, S. L. Painter, and N. Makedonska. Conforming Delaunay triangulation of stochastically generated three dimensional discrete fracture networks: A feature rejection algorithm for meshing strategy. SIAM J. Sci. Comput., 36(4):A1871\textendash{}A1894, 2014

\item {} 
R.S. Middleton, J.W. Carey, R.P. Currier, J. D. Hyman, Q. Kang, S. Karra, J. Jimenez-Martınez, M.L. Porter, and H.S. Viswanathan. Shale gas and non-aqueous fracturing fluids: Opportunities and challenges for supercritical CO2. Applied Energy, 147:500\textendash{}509, 2015

\item {} 
J. D. Hyman, S. L. Painter, H. Viswanathan, N. Makedonska, and S. Karra. Influence of injection mode on transport properties in kilometer-scale three-dimensional discrete fracture networks. Water Resources Research, 51(9):7289\textendash{}7308, 2015

\item {} 
S. Karra, Nataliia Makedonska, Hari S Viswanathan, Scott L Painter, and Jeffrey D. Hyman. Effect of advective flow in fractures and matrix diffusion on natural gas production. Water Resources Research, 51(10):8646\textendash{}8657, 2015

\item {} 
J. D. Hyman, S. Karra, N. Makedonska, C. W Gable, S. L Painter, and H. S Viswanathan. dfnWorks: A discrete fracture network framework for modeling subsurface flow and transport. Computers \& Geosciences, 84:10\textendash{}19, 2015

\item {} 
H. S. Viswanathan, J. D. Hyman, S. Karra, J.W. Carey, M. L. Porter, E. Rougier, R. P. Currier,Q. Kang, L. Zhou, J. Jimenez-Martınez, N. Makedonska, L. Chen, and R. S. Middleton. Using Discovery Science To Increase Efficiency of Hydraulic Fracturing While Reducing Water Usage, chapter 4, pages 71\textendash{}88. ACS Publications, 2016

\item {} 
N. Makedonska, S. L Painter, Q. M Bui, C. W Gable, and S. Karra. Particle tracking approach for transport in three-dimensional discrete fracture networks. Computational Geosciences, 19(5):1123\textendash{}1137, 2015

\item {} 
D. O’Malley, S. Karra, R. P. Currier, N. Makedonska, J. D. Hyman, and H. S. Viswanathan. Where does water go during hydraulic fracturing? Groundwater, 54(4):488\textendash{}497, 2016

\item {} 
J. D. Hyman, J Jim´enez-Mart´ınez, HS Viswanathan, JW Carey, ML Porter, E Rougier, S Karra, Q Kang, L Frash, L Chen, et al. Understanding hydraulic fracturing: a multi-scale problem. Phil. Trans. R. Soc. A, 374(2078):20150426, 2016

\item {} 
G. Aldrich, J. D. Hyman, S. Karra, C. W. Gable, N. Makedonska, H. Viswanathan, J.Woodring, and B. Hamann. Analysis and visualization of discrete fracture networks using a flow topology graph. IEEE Transactions on Visualization and Computer Graphics, 23(8):1896\textendash{}1909, Aug 2017

\item {} 
N. Makedonska, J. D. Hyman, S. Karra, S. L. Painter, C.W. Gable, and H. S. Viswanathan. Evaluating the effect of internal aperture variability on transport in kilometer scale discrete fracture networks. Advances in Water Resources, 94:486 \textendash{} 497, 2016

\item {} 
J. D. Hyman, G. Aldrich, H. Viswanathan, N. Makedonska, and S. Karra. Fracture size and transmissivity correlations: Implications for transport simulations in sparse three-dimensional discrete fracture networks following a truncated power law distribution of fracture size. Water Resources Research, 2016

\item {} 
H. Djidjev, D. O’Malley, H. Viswanathan, J. D. Hyman, S. Karra, and G. Srinivasan. Learningon graphs for predictions of fracture propagation, flow and transport. In 2017 IEEE International Parallel and Distributed Processing Symposium Workshops (IPDPSW), pages 1532\textendash{}1539, May 2017

\item {} 
J. D. Hyman, A. Hagberg, G. Srinivasan, J. Mohd-Yusof, and H. Viswanathan. Predictions of first passage times in sparse discrete fracture networks using graph-based reductions. Phys. Rev. E, 96:013304, Jul 2017

\item {} 
T Hadgu, S. Karra, N. Makedonska, J. D. Hyman, K. Klise, H. S. Viswanathan, and Y.Wang. A comparative study of discrete fracture network and equivalent continuum models for simulating flow and transport in the far field of a hypothetical nuclear waste repository in crystalline host rock. J. Hydrology, 2017

\item {} 
V. Romano, J. D. Hyman, S. Karra, A. J. Valocchi, M. Battaglia, and S. Bigi. Numerical modeling of fluid flow in a fault zone: a case of study from majella mountain (Italy). Energy Procedia, 125:556 \textendash{} 560, 2017

\item {} 
M. Valera, Z. Guo, P. Kelly, S. Matz, A. Cantu, A.G. Percus, J. D. Hyman, G. Srinivasan, and H.S. Viswanathan. Machine learning for graph-based representations of three-dimensional discrete fracture networks. Computational Geosciences, 2018

\item {} 
M. K. Mudunuru, S. Karra, N. Makedonska, and T. Chen. Sequential geophysical and flow inversion to characterize fracture networks in subsurface systems. Statistical Analysis and Data Mining: The ASA Data Science Journal, 10(5):326\textendash{}342, 2017

\item {} 
J. D. Hyman, Satish Karra, J. William Carey, Carl W. Gable, Hari Viswanathan, Esteban Rougier, and Zhou Lei. Discontinuities in effective permeability due to fracture percolation. Mechanics of Materials, 119:25 \textendash{} 33, 2018

\item {} 
S. Karra, D. O’Malley, J. D. Hyman, H.S. Viswanathan, and G. Srinivasan. Modeling flow and transport in fracture networks using graphs. Phys. Rev. E, 2018

\item {} 
J. D. Hyman and J. Jimenéz-Martínez. Dispersion and mixing in three-dimensional discrete fracture networks: Nonlinear interplay between structural and hydraulic heterogeneity. Water Resources Research, 54(5):3243\textendash{}3258, 2018

\item {} 
D. O’Malley, S. Karra, J. D. Hyman, H. Viswanathan, and G. Srinivasan. Efficient monte carlo with graph-based subsurface flow and transport models. Water Resour. Res., 2018

\item {} 
G. Srinivasan, J. D. Hyman, D. Osthus, B. Moore, D. O’Malley, S. Karra, E Rougier, A. Hagberg, A. Hunter, and H. S. Viswanathan. Quantifying topological uncertainty in fractured systems using graph theory and machine learning. Scientific Reports, 2018

\item {} 
H. S. Viswanathan, J. D. Hyman, S. Karra, D. O’Malley, S. Srinivasan, A. Hagberg, and G. Srinivasan. Advancing graph-based algorithms for predicting flow and transport in fractured rock. Water Resour. Res., 2018

\item {} 
S. Srinivasan, J. D. Hyman, S. Karra, D. O’Malley, H. Viswanathan, and G. Srinivasan. Robust system size reduction of discrete fracture networks: A multi-fidelity method that preserves transport characteristics. Computational Geosciences, 2018

\item {} 
J. D. Hyman, Aric Hagberg, Dave Osthus, Shriram Srinivasan, Hari Viswanathan, and Gowri Srinivasan. Identifying backbones in three-dimensional discrete fracture net- works: A bipartite graph-based approach. Multiscale Modeling \& Simulation, 16(4):1948\textendash{} 1968, 2018

\item {} 
G. Aldrich, J. Lukasczyk, J. D. Hyman, G. Srinivasan, H. Viswanathan, C. Garth, H. Leitte, J. Ahrens, and B. Hamann. A query-based framework for searching,sorting, and exploring data ensembles. Computing in Science Engineering, 2018

\item {} 
T. Sherman, J. D. Hyman, D. Bolster, N. Makedonska, and G. Srinivasan. Characteriz- ing the impact of particle behavior at fracture intersections in three-dimensional discrete fracture networks. Physical Review E, 99(1):013110, 2019

\item {} 
J. D. Hyman, M. Dentz, A. Hagberg, and P. Kang. Linking structural and transport properties in three-dimensional fracture networks. J. Geophys. Res. Sol. Ea., 2019

\item {} 
S. Srinivasan, S. Karra, J. D. Hyman, H. Viswanathan, and G. Srinivasan. Model re- duction for fractured porous media: A machine-learning approach for identifying main flow pathways. Computational Geosciences, 2018

\item {} 
N. Makedonska, J. Hyman, E. Kwicklis, K. Birdsell, Conference Proceedings, Discrete Fracture Network Modeling and Simulation of Subsurface Transport for the Topopah Spring Aquifer at Pahute Mesa, 2nd International Discrete Fracture Network Engineering, 2018.

\item {} 
N. Makedonska, C.W. Gable, R. Pawar, Conference Proceedings, Merging Discrete Fracture Network Meshes With 3D Continuum Meshes of Rock Matrix: A Novel Approach, 2nd International Discrete Fracture Network Engineering, 2018.

\end{enumerate}


\chapter{pydfnworks: the dfnWorks python package}
\label{\detokenize{pydfnworks:pydfnworks-the-dfnworks-python-package}}\label{\detokenize{pydfnworks:dfnworks-python-chapter}}\label{\detokenize{pydfnworks::doc}}
The pydfnworks package allows the user to run dfnWorks from the command line and  call dfnWorks within other python scripts. Because pydfnworks is a package, users can call individual methods from the package.

The pydfnworks must be setup by the user using the following command in the directory \sphinxcode{\sphinxupquote{dfnWorks-Version2.0/pydfnworks/}} :

\sphinxcode{\sphinxupquote{python setup.py install}} (if the user has admin privileges), OR:

\sphinxcode{\sphinxupquote{python setup.py install -{-}user}} (if the user does not have admin privileges):

The documentation below includes methods and classes of the pydfnworks package.


\section{DFN Class and Setup}
\label{\detokenize{pydfnworks:module-pydfnworks.general.dfnworks}}\label{\detokenize{pydfnworks:dfn-class-and-setup}}\index{pydfnworks.general.dfnworks (module)@\spxentry{pydfnworks.general.dfnworks}\spxextra{module}}\index{DFNWORKS (class in pydfnworks.general.dfnworks)@\spxentry{DFNWORKS}\spxextra{class in pydfnworks.general.dfnworks}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pydfnworks.general.dfnworks.}}\sphinxbfcode{\sphinxupquote{DFNWORKS}}}{\emph{jobname=''}, \emph{ncpu=''}, \emph{local\_jobname=''}, \emph{dfnGen\_file=''}, \emph{output\_file=''}, \emph{local\_dfnGen\_file=''}, \emph{dfnFlow\_file=''}, \emph{local\_dfnFlow\_file=''}, \emph{dfnTrans\_file=''}, \emph{path=''}, \emph{prune\_file=''}, \emph{flow\_solver='PFLOTRAN'}, \emph{inp\_file='full\_mesh.inp'}, \emph{uge\_file=''}, \emph{stor\_file=''}, \emph{vtk\_file=''}, \emph{mesh\_type='dfn'}, \emph{perm\_file=''}, \emph{aper\_file=''}, \emph{perm\_cell\_file=''}, \emph{aper\_cell\_file=''}, \emph{dfnTrans\_version=''}, \emph{num\_frac=''}, \emph{h=''}}{}
Class for DFN Generation and meshing


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~jobname}}}
name of job, also the folder where output files are stored

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~ncpu}}}
number of CPUs used in the job

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~dfnGen~file}}}
the name of the dfnGen input file

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~dfnFlow~file}}}
the name of the dfnFlow input file

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~dfnTrans~file}}}
the name of the dfnFlow input file

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~local~prefix}}}
indicates that the name contains only the most local directory

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~vtk\_file}}}
the name of the VTK file

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~inp\_file}}}
the name of the INP file

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~uge\_file}}}
the name of the UGE file

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~mesh\_type}}}
the type of mesh

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~perm\_file}}}
the name of the file containing permeabilities

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~aper\_file}}}
the name of the file containing apertures

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~perm\_cell~file}}}
the name of the file containing cell permeabilities

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~aper\_cell\_file}}}
the name of the file containing cell apertures

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~freeze}}}
indicates whether the class attributes can be modified

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~h}}}
FRAM length scale

\end{fulllineitems}

\index{check\_dfn\_trans\_run\_files() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{check\_dfn\_trans\_run\_files()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.check_dfn_trans_run_files}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_dfn\_trans\_run\_files}}}{}{}
Ensures that all files required for dfnTrans run are in the current directory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}

\index{check\_input() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{check\_input()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.check_input}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_input}}}{\emph{input\_file=''}, \emph{output\_file=''}}{}
Check input file for DFNGen to make sure all necessary parameters are defined
\begin{quote}
\begin{description}
\item[{Input Format Requirements:}] \leavevmode\begin{itemize}
\item {} 
Each parameter must be defined on its own line (separate by newline)

\item {} 
A parameter (key) MUST be separated from its value by a colon ‘:’ (ie. \textendash{}\textgreater{} key: value)

\item {} 
Values may also be placed on lines after the ‘key’

\item {} 
Comment Format:  On a line containing  // or / \sphinxcode{\sphinxupquote{*}}, nothing after \sphinxcode{\sphinxupquote{*}} / or // will be processed  but text before a comment will be processed

\end{itemize}

\end{description}
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{input\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of dfnGen input file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of stripped down input file for DFNGen (input\_file\_clean.dat)

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

There are warnings and errors raised in this function. Warning will let you continue while errors will stop the run. Continue past warnings are your own risk.

\end{fulllineitems}

\index{copy\_dfn\_trans\_files() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{copy\_dfn\_trans\_files()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.copy_dfn_trans_files}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy\_dfn\_trans\_files}}}{}{}
Creates symlink to dfnTrans Execuateble and copies input files for dfnTrans into working directory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{correct\_stor\_file() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{correct\_stor\_file()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.correct_stor_file}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{correct\_stor\_file}}}{}{}
Corrects volumes in stor file to account for apertures
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Currently does not work with cell based aperture

\end{fulllineitems}

\index{create\_dfn\_flow\_links() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{create\_dfn\_flow\_links()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.create_dfn_flow_links}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_dfn\_flow\_links}}}{\emph{path='../'}}{}
Create symlinks to files required to run dfnFlow that are in another directory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Absolute path to primary directory.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Typically, the path is DFN.path, which is set by the command line argument -path

\item {} 
Currently only supported for PFLOTRAN

\end{enumerate}

\end{fulllineitems}

\index{create\_dfn\_trans\_links() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{create\_dfn\_trans\_links()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.create_dfn_trans_links}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_dfn\_trans\_links}}}{\emph{path='../'}}{}
Create symlinks to files required to run dfnTrans that are in another directory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Absolute path to primary directory.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Typically, the path is DFN.path, which is set by the command line argument -path

\end{fulllineitems}

\index{create\_graph() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{create\_graph()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.create_graph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_graph}}}{\emph{graph\_type}, \emph{inflow}, \emph{outflow}}{}
Header function to create a graph based on a DFN
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{graph\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Option for what graph representation of the DFN is requested. Currently supported are fracture, intersection, and bipartitie

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of inflow boundary (connect to source)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of outflow boundary (connect to target)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{G} \textendash{} Graph based on DFN

\item[{Return type}] \leavevmode
NetworkX Graph

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{create\_network() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{create\_network()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.create_network}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_network}}}{}{}
Execute dfnGen
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

After generation is complete, this script checks whether the generation of the fracture network failed or succeeded based on the existance of the file params.txt.

\end{fulllineitems}

\index{define\_paths() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{define\_paths()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.define_paths}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{define\_paths}}}{}{}
Defines enviromental variables for use in dfnWorks. The user must change these to match their workspace.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{None}} \textendash{} 

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Enviromental variables are set to executables

\end{fulllineitems}

\index{dfn\_flow() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{dfn\_flow()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.dfn_flow}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dfn\_flow}}}{\emph{dump\_vtk=True}, \emph{effective\_perm=True}}{}
Run the dfnFlow portion of the workflow
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dump\_vtk}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} True - Write out vtk files for flow solutions
False  - Does not write out vtk files for flow solutions

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Information on individual functions is found therein

\end{fulllineitems}

\index{dfn\_gen() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{dfn\_gen()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.dfn_gen}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dfn\_gen}}}{\emph{output=True}, \emph{visual\_mode=None}}{}~\begin{description}
\item[{Wrapper script the runs the dfnGen workflow:}] \leavevmode\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi )}
\makeatletter\def\p@enumii{\p@enumi \theenumi )}\makeatother
\item {} 
make\_working\_directory: Create a directory with name of job

\item {} 
check\_input: Check input parameters and create a clean version of the input file

\item {} 
create\_network: Create network. DFNGEN v2.0 is called and creates the network

\item {} 
output\_report: Generate a PDF summary of the DFN generation

\item {} 
mesh\_network: calls module dfnGen\_meshing and runs LaGriT to mesh the DFN

\end{enumerate}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, output pdf will be created. If False, no pdf is made

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visual\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} If the user wants to run in a different meshing mode from what is in params.txt, set visual\_mode = True/False on command line to override meshing mode

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Details of each portion of the routine are in those sections

\end{fulllineitems}

\index{dfn\_trans() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{dfn\_trans()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.dfn_trans}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dfn\_trans}}}{}{}
Primary driver for dfnTrans.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{dump\_fractures() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{dump\_fractures()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.dump_fractures}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dump\_fractures}}}{\emph{G}, \emph{filename}}{}
Write fracture numbers assocaited with the graph G out into an ASCII file inputs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} NetworkX Graph based on the DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Output filename

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{dump\_json\_graph() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{dump\_json\_graph()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.dump_json_graph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dump\_json\_graph}}}{\emph{G}, \emph{name}}{}
Write graph out in json format
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{networkX graph}}) \textendash{} NetworkX Graph based on the DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of output file (no .json)

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{dump\_time() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{dump\_time()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.dump_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dump\_time}}}{\emph{function\_name}, \emph{time}}{}
Write run time for a funcion to the jobname\_run\_time.txt file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{function\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of function that was timed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Run time of function in seconds

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

While this function is working, the current formulation is not robust through the entire workflow

\end{fulllineitems}

\index{effective\_perm() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{effective\_perm()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.effective_perm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{effective\_perm}}}{}{}
Computes the effective permeability of a DFN in the primary direction of flow using a steady-state PFLOTRAN solution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Information is written to screen and to the file self.local\_jobname\_effective\_perm.txt

\item {} 
Currently, only PFLOTRAN solutions are supported

\item {} 
Assumes density of water

\end{enumerate}

\end{fulllineitems}

\index{fehm() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{fehm()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.fehm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fehm}}}{}{}
Run FEHM
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

See \sphinxurl{https://fehm.lanl.gov/} for details about FEHM

\end{fulllineitems}

\index{greedy\_edge\_disjoint() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{greedy\_edge\_disjoint()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.greedy_edge_disjoint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{greedy\_edge\_disjoint}}}{\emph{G}, \emph{source='s'}, \emph{target='t'}, \emph{weight='None'}, \emph{k=''}}{}
Greedy Algorithm to find edge disjoint subgraph from s to t.
See Hyman et al. 2018 SIAM MMS
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class Object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} NetworkX Graph based on the DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Starting node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Ending node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Edge weight used for finding the shortest path

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of edge disjoint paths requested

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{H} \textendash{} Subgraph of G made up of the k shortest of all edge-disjoint paths from source to target

\item[{Return type}] \leavevmode
NetworkX Graph

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Edge weights must be numerical and non-negative.

\item {} 
See Hyman et al. 2018 “Identifying Backbones in Three-Dimensional Discrete Fracture Networks: A Bipartite Graph-Based Approach” SIAM Multiscale Modeling and Simulation for more details

\end{enumerate}

\end{fulllineitems}

\index{inp2gmv() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{inp2gmv()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.inp2gmv}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inp2gmv}}}{\emph{inp\_file=''}}{}
Convert inp file to gmv file, for general mesh viewer. Name of output file for base.inp is base.gmv
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inp\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of inp file if not an attribure of self

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{inp2vtk\_python() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{inp2vtk\_python()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.inp2vtk_python}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inp2vtk\_python}}}{}{}
Using Python VTK library, convert inp file to VTK file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

For a mesh base.inp, this dumps a VTK file named base.vtk

\end{fulllineitems}

\index{k\_shortest\_paths\_backbone() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{k\_shortest\_paths\_backbone()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.k_shortest_paths_backbone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{k\_shortest\_paths\_backbone}}}{\emph{G}, \emph{k}, \emph{source='s'}, \emph{target='t'}, \emph{weight=None}}{}
Returns the subgraph made up of the k shortest paths in a graph
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX Graph}}) \textendash{} NetworkX Graph based on a DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of requested paths

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Starting node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Ending node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Edge weight used for finding the shortest path

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{H} \textendash{} Subgraph of G made up of the k shortest paths

\item[{Return type}] \leavevmode
NetworkX Graph

\end{description}\end{quote}
\subsubsection*{Notes}

See Hyman et al. 2017 “Predictions of first passage times in sparse discrete fracture networks using graph-based reductions” Physical Review E for more details

\end{fulllineitems}

\index{lagrit2pflotran() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{lagrit2pflotran()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.lagrit2pflotran}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{lagrit2pflotran}}}{\emph{inp\_file=''}, \emph{mesh\_type=''}, \emph{hex2tet=False}}{}
Takes output from LaGriT and processes it for use in PFLOTRAN.
Calls the functuon write\_perms\_and\_correct\_volumes\_areas() and zone2ex
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inp\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the inp (AVS) file produced by LaGriT

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mesh\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The type of mesh

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hex2tet}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} True if hex mesh elements should be converted to tet elements, False otherwise.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}

\index{legal() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{legal()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.legal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{legal}}}{}{}
Print the legal LANL statement for dfnWorks.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}

\index{load\_json\_graph() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{load\_json\_graph()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.load_json_graph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_json\_graph}}}{\emph{name}}{}
Read in graph from json format
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of input file (no .json)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{G} \textendash{} NetworkX Graph based on the DFN

\item[{Return type}] \leavevmode
networkX graph

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_working\_directory() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{make\_working\_directory()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.make_working_directory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{make\_working\_directory}}}{}{}
Make working directory for dfnWorks Simulation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class object

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

If directory already exists, user is prompted if they want to overwrite and proceed. If not, program exits.

\end{fulllineitems}

\index{mesh\_network() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{mesh\_network()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.mesh_network}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mesh\_network}}}{\emph{prune=False}, \emph{uniform\_mesh=False}, \emph{production\_mode=True}, \emph{refine\_factor=1}, \emph{slope=2}, \emph{visual\_mode=None}}{}
Mesh fracture network using LaGriT
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prune}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If prune is False, mesh entire network. If prune is True, mesh only fractures in self.prune\_file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uniform\_mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, mesh is uniform resolution. If False, mesh is spatially variable

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{production\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, all working files while meshing are cleaned up. If False, then working files will not be deleted

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refine\_factor}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Determines distance for mesh refinement (default=1)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{slope}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Slope of piecewise linear function determining rate of coarsening.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visual\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} If the user wants to run in a different meshing mode from what is in params.txt, set visual\_mode = True/False on command line to override meshing mode

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
For uniform resolution mesh, set slope = 0

\item {} 
All fractures in self.prune\_file must intersect at least 1 other fracture

\end{enumerate}

\end{fulllineitems}

\index{output\_report() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{output\_report()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.output_report}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{output\_report}}}{\emph{radiiFile='radii.dat'}, \emph{famFile='families.dat'}, \emph{transFile='translations.dat'}, \emph{rejectFile='rejections.dat'}, \emph{output\_name=''}}{}
Create PDF report of generator
\begin{quote}
\begin{description}
\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
Set the number of histogram buckets (bins) by changing numBuckets variable in his graphing functions

\item {} 
Also change number of x-values used to plot lines by changing numXpoints variable in appropriate funcs

\item {} 
Set show = True to show plots immediately and still make pdf

\item {} 
NOTE future developers of this code should add functionality for radiiList of size 0.

\end{itemize}

\end{description}
\end{quote}

\end{fulllineitems}

\index{parse\_pflotran\_vtk\_python() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{parse\_pflotran\_vtk\_python()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.parse_pflotran_vtk_python}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parse\_pflotran\_vtk\_python}}}{\emph{grid\_vtk\_file=''}}{}
Replace CELL\_DATA with POINT\_DATA in the VTK output.
:param self: DFN Class
:type self: object
:param grid\_vtk\_file: Name of vtk file with mesh. Typically local\_dfnFlow\_file.vtk
:type grid\_vtk\_file: string
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

If DFN class does not have a vtk file, inp2vtk\_python is called

\end{fulllineitems}

\index{pflotran() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{pflotran()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.pflotran}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pflotran}}}{\emph{restart=False}, \emph{restart\_file=''}}{}
Run PFLOTRAN. Copy PFLOTRAN run file into working directory and run with ncpus
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Runs PFLOTRAN Executable, see \sphinxurl{http://www.pflotran.org/} for details on PFLOTRAN input cards

\end{fulllineitems}

\index{pflotran\_cleanup() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{pflotran\_cleanup()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.pflotran_cleanup}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pflotran\_cleanup}}}{\emph{index\_start=0}, \emph{index\_finish=1}, \emph{filename=''}}{}
Concatenate PFLOTRAN output files and then delete them
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} If PFLOTRAN has multiple dumps use this to pick which dump is put into cellinfo.dat and darcyvel.dat

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Can be run in a loop over all pflotran dumps

\end{fulllineitems}

\index{plot\_graph() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{plot\_graph()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.plot_graph}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_graph}}}{\emph{G}, \emph{source='s'}, \emph{target='t'}, \emph{output\_name='dfn\_graph'}}{}
Create a png of a graph with source nodes colored blue, target red, and all over nodes black
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} NetworkX Graph based on the DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Starting node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Ending node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of output file (no .png)

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Image is written to output\_name.png

\end{fulllineitems}

\index{print\_run\_time() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{print\_run\_time()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.print_run_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{print\_run\_time}}}{}{}
Read in run times from file and and print to screen with percentages
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

This will dump out all values in the run file, not just those from the most recent run

\end{fulllineitems}

\index{pydfnworks (pydfnworks.general.dfnworks.DFNWORKS attribute)@\spxentry{pydfnworks}\spxextra{pydfnworks.general.dfnworks.DFNWORKS attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.pydfnworks}}\pysigline{\sphinxbfcode{\sphinxupquote{pydfnworks}}\sphinxbfcode{\sphinxupquote{ = \textless{}module 'pydfnworks' from '/Users/jhyman/.local/lib/python3.7/site-packages/pydfnworks-2.2-py3.7.egg/pydfnworks/\_\_init\_\_.py'\textgreater{}}}}
\end{fulllineitems}

\index{run\_dfn\_trans() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{run\_dfn\_trans()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.run_dfn_trans}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_dfn\_trans}}}{}{}
Execute dfnTrans
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_graph\_flow() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{run\_graph\_flow()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.run_graph_flow}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_graph\_flow}}}{\emph{inflow}, \emph{outflow}, \emph{Pin}, \emph{Pout}, \emph{fluid\_viscosity=0.00089}}{}
Run the graph flow portion of the workflow
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} \textendash{} DFN Class

\item[{Returns}] \leavevmode
\sphinxstylestrong{Gtilde} \textendash{} Grtilde is updated with vertex pressures, edge fluxes and travel times

\item[{Return type}] \leavevmode
NetworkX graph

\end{description}\end{quote}
\subsubsection*{Notes}

Information on individual functions in found therein

\end{fulllineitems}

\index{run\_graph\_transport() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{run\_graph\_transport()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.run_graph_transport}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_graph\_transport}}}{\emph{Gtilde}, \emph{nparticles}, \emph{partime\_file=None}, \emph{frac\_id\_file=None}}{}
Run  particle tracking on the given NetworkX graph
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Gtilde}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} obtained from graph\_flow

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nparticles}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of particles

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{partime\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of file to  which the total travel times and lengths will be written for each particle, default is None

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{frac\_id\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of file to which detailed information of each particle’s travel will be written, default is None

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Information on individual functions is found therein

\end{fulllineitems}

\index{set\_flow\_solver() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{set\_flow\_solver()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.set_flow_solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_flow\_solver}}}{\emph{flow\_solver}}{}
Sets flow solver to be used
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{flow\_solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of flow solver. Currently supported flow sovlers are FEHM and PFLOTRAN

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Default is PFLOTRAN

\end{fulllineitems}

\index{uncorrelated() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{uncorrelated()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.uncorrelated}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{uncorrelated}}}{\emph{mu}, \emph{sigma}, \emph{path='../'}}{}
Creates Fracture Based Log-Normal Permeability field with mean mu and variance sigma. Aperture is dervived using the cubic law
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mu}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Mean of LogNormal Permeability field

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigma}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Variance of permeability field

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} path to original network. Can be current directory

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

mu is the mean of perm not log(perm)

\end{fulllineitems}

\index{write\_perms\_and\_correct\_volumes\_areas() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{write\_perms\_and\_correct\_volumes\_areas()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.write_perms_and_correct_volumes_areas}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write\_perms\_and\_correct\_volumes\_areas}}}{}{}
Write permeability values to perm\_file, write aperture values to aper\_file, and correct volume areas in uge\_file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Calls executable correct\_uge

\end{fulllineitems}

\index{zone2ex() (pydfnworks.general.dfnworks.DFNWORKS method)@\spxentry{zone2ex()}\spxextra{pydfnworks.general.dfnworks.DFNWORKS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.DFNWORKS.zone2ex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{zone2ex}}}{\emph{uge\_file=''}, \emph{zone\_file=''}, \emph{face=''}, \emph{boundary\_cell\_area=0.1}}{}
Convert zone files from LaGriT into ex format for LaGriT
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uge\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of uge file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of zone file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Face}} (\sphinxstyleliteralemphasis{\sphinxupquote{Face of the plane corresponding to the zone file}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone\_file}} \textendash{} Name of zone file to work on. Can be ‘all’ processes all directions, top, bottom, left, right, front, back

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{boundary\_cell\_area}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Boundary cells are moved a distance of boundary\_cell\_area 1e-1

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

the boundary\_cell\_area should be a function of h, the mesh resolution

\end{fulllineitems}


\end{fulllineitems}

\index{commandline\_options() (in module pydfnworks.general.dfnworks)@\spxentry{commandline\_options()}\spxextra{in module pydfnworks.general.dfnworks}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.commandline_options}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.general.dfnworks.}}\sphinxbfcode{\sphinxupquote{commandline\_options}}}{}{}
Read command lines for use in dfnWorks.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{None}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxstylestrong{options} \textendash{} command line options

\item[{Return type}] \leavevmode
argparse function

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{description}
\item[{Options:}] \leavevmode\begin{description}
\item[{-name}] \leavevmode{[}string{]}
Path to working directory (Mandatory)

\item[{-ncpu}] \leavevmode{[}int{]}
Number of CPUS (Optional, default=4)

\item[{-input}] \leavevmode{[}string{]}
Input file with paths to run files (Mandatory if the next three options are not specified)

\item[{-gen}] \leavevmode{[}string{]}
Generator Input File (Mandatory, can be included within the input file)

\item[{-flow}] \leavevmode{[}string{]}
PFLORAN Input File (Mandatory, can be included within the input file)

\item[{-trans}] \leavevmode{[}string{]}
Transport Input File (Mandatory, can be included within the input file)

\item[{-prune\_file}] \leavevmode{[}string{]}
Absolute path to the prune Input File

\item[{-path}] \leavevmode{[}string{]}
Path to another DFN run that you want to base the current run from

\item[{-cell}] \leavevmode{[}bool{]}
True/False Set True for use with cell based aperture and permeabuility (Optional, default=False)

\end{description}

\end{description}

\end{fulllineitems}

\index{create\_dfn() (in module pydfnworks.general.dfnworks)@\spxentry{create\_dfn()}\spxextra{in module pydfnworks.general.dfnworks}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.dfnworks.create_dfn}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.general.dfnworks.}}\sphinxbfcode{\sphinxupquote{create\_dfn}}}{}{}
Parse command line inputs and input files to create and populate dfnworks class
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{None}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxstylestrong{DFN} \textendash{} DFN class object populated with information parsed from the command line. Information about DFN class is in dfnworks.py

\item[{Return type}] \leavevmode
object

\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}



\section{dfnGen}
\label{\detokenize{pydfnworks:dfngen}}

\subsection{Processing generator input}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnGen.gen_input}}\label{\detokenize{pydfnworks:processing-generator-input}}\index{pydfnworks.dfnGen.gen\_input (module)@\spxentry{pydfnworks.dfnGen.gen\_input}\spxextra{module}}\index{check\_input() (in module pydfnworks.dfnGen.gen\_input)@\spxentry{check\_input()}\spxextra{in module pydfnworks.dfnGen.gen\_input}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.check_input}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.gen\_input.}}\sphinxbfcode{\sphinxupquote{check\_input}}}{\emph{self}, \emph{input\_file=''}, \emph{output\_file=''}}{}
Check input file for DFNGen to make sure all necessary parameters are defined
\begin{quote}
\begin{description}
\item[{Input Format Requirements:}] \leavevmode\begin{itemize}
\item {} 
Each parameter must be defined on its own line (separate by newline)

\item {} 
A parameter (key) MUST be separated from its value by a colon ‘:’ (ie. \textendash{}\textgreater{} key: value)

\item {} 
Values may also be placed on lines after the ‘key’

\item {} 
Comment Format:  On a line containing  // or / \sphinxcode{\sphinxupquote{*}}, nothing after \sphinxcode{\sphinxupquote{*}} / or // will be processed  but text before a comment will be processed

\end{itemize}

\end{description}
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{input\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of dfnGen input file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of stripped down input file for DFNGen (input\_file\_clean.dat)

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

There are warnings and errors raised in this function. Warning will let you continue while errors will stop the run. Continue past warnings are your own risk.

\end{fulllineitems}

\index{input\_helper (class in pydfnworks.dfnGen.gen\_input)@\spxentry{input\_helper}\spxextra{class in pydfnworks.dfnGen.gen\_input}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.gen\_input.}}\sphinxbfcode{\sphinxupquote{input\_helper}}}{\emph{params}, \emph{minFracSize}}{}
Functions to help parse the input file and check input parameters.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~params}}}
list of parameters specified in the input file.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~minFracSize}}}
the minimum fracture size.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_fam\_count() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{check\_fam\_count()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.check_fam_count}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_fam\_count}}}{}{}
Makes sure at least one polygon family has been defined in nFamRect or nFamEll
OR that there is a user input file for polygons.

\end{fulllineitems}

\index{check\_mean() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{check\_mean()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.check_mean}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_mean}}}{\emph{minParam}, \emph{maxParam}, \emph{meanParam}, \emph{warningFile=''}}{}
Warns the user if the minimum value of a parameter is greater than the family’s mean value, or if the
maximum value of the parameter is less than the family’s mean value.

\end{fulllineitems}

\index{check\_min\_frac\_size() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{check\_min\_frac\_size()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.check_min_frac_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_min\_frac\_size}}}{\emph{valList}}{}
Corrects the minimum fracture size if necessary, by looking at the values in valList.

\end{fulllineitems}

\index{check\_min\_max() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{check\_min\_max()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.check_min_max}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_min\_max}}}{\emph{minParam}, \emph{maxParam}, \emph{shape}}{}
Checks that the minimum parameter for a family is not greater or equal to the maximum parameter.

\end{fulllineitems}

\index{curly\_to\_list() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{curly\_to\_list()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.curly_to_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{curly\_to\_list}}}{\emph{curlyList}}{}
‘\{1,2,3\}’ \textendash{}\textgreater{} {[}1,2,3{]}

\end{fulllineitems}

\index{error() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{error()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.error}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{error}}}{\emph{errString}}{}
print an error
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{errString}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} a string describing the error

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_parameters() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{extract\_parameters()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.extract_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extract\_parameters}}}{\emph{line}, \emph{inputIterator}}{}
Returns line without comments or white space.

\end{fulllineitems}

\index{find\_key() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{find\_key()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.find_key}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{find\_key}}}{\emph{line}, \emph{unfoundKeys}, \emph{warningFile}}{}
Input: line containing a paramter (key) preceding a “:”
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
key \textendash{} if it has not been defined yet and is valid

\item {} 
None \textendash{} if key does not exist

\item {} 
exits \textendash{} if the key has already been defined to prevent duplicate confusion

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{find\_val() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{find\_val()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.find_val}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{find\_val}}}{\emph{line}, \emph{key}, \emph{inputIterator}, \emph{unfoundKeys}, \emph{warningFile}}{}
Extract the value for key from line.

\end{fulllineitems}

\index{get\_groups() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{get\_groups()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.get_groups}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_groups}}}{\emph{line}, \emph{valList}, \emph{key}}{}
extract values between \{ and \}

\end{fulllineitems}

\index{has\_curlys() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{has\_curlys()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.has_curlys}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{has\_curlys}}}{\emph{line}, \emph{key}}{}
Checks to see that every \{ has a matching \}.

\end{fulllineitems}

\index{is\_negative() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{is\_negative()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.is_negative}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_negative}}}{\emph{num}}{}
“returns True if num is negative, false otherwise

\end{fulllineitems}

\index{list\_to\_curly() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{list\_to\_curly()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.list_to_curly}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{list\_to\_curly}}}{\emph{strList}}{}
{[}1,2,3{]} \textendash{}\textgreater{} ‘\{1,2,3\}’   for writing output

\end{fulllineitems}

\index{process\_line() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{process\_line()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.process_line}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{process\_line}}}{\emph{line}, \emph{unfoundKeys}, \emph{inputIterator}, \emph{warningFile}}{}
Find the key in a line, and the value for that key.

\end{fulllineitems}

\index{scale() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{scale()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.scale}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scale}}}{\emph{probList}, \emph{warningFile}}{}
scales list of probabilities (famProb) that doesn’t add up to 1
ie {[}.2, .2, .4{]} \textendash{}\textgreater{} {[}0.25, 0.25, 0.5{]}

\end{fulllineitems}

\index{val\_helper() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{val\_helper()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.val_helper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{val\_helper}}}{\emph{line}, \emph{valList}, \emph{key}}{}
pulls values from culry brackets

\end{fulllineitems}

\index{value\_of() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{value\_of()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.value_of}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{value\_of}}}{\emph{key}, \emph{writing=False}}{}
Use to get key’s value in params. writing always false

\end{fulllineitems}

\index{verify\_flag() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{verify\_flag()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.verify_flag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{verify\_flag}}}{\emph{value}, \emph{key=''}, \emph{inList=False}}{}
Verify that value is either a 0 or a 1.

\end{fulllineitems}

\index{verify\_float() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{verify\_float()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.verify_float}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{verify\_float}}}{\emph{value}, \emph{key=''}, \emph{inList=False}, \emph{noNeg=False}}{}
Verify that value is a positive float.

\end{fulllineitems}

\index{verify\_int() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{verify\_int()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.verify_int}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{verify\_int}}}{\emph{value}, \emph{key=''}, \emph{inList=False}, \emph{noNeg=False}}{}
Verify that value is a positive integer.

\end{fulllineitems}

\index{verify\_list() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{verify\_list()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.verify_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{verify\_list}}}{\emph{valList}, \emph{key}, \emph{verificationFn}, \emph{desiredLength}, \emph{noZeros=False}, \emph{noNegs=False}}{}
verifies input list that come in format \{0, 1, 2, 3\}
\begin{description}
\item[{Input:}] \leavevmode\begin{itemize}
\item {} 
valList - list of values (flags, floats, or ints) corresponding to a parameter

\item {} 
key - the name of the parameter whose list is being verified

\item {} 
verificationFn - (either verifyflag, verifyfloat or verifyint) checks each list element

\item {} 
desiredLength - how many elements are supposed to be in the list

\item {} 
noZeros - (optional) True for lists than cannot contain 0’s, false if 0’s are ok

\item {} 
noNegs - (optional) True for lists than cannot contain negative numbers, false otherwise

\end{itemize}

\item[{Output:}] \leavevmode\begin{itemize}
\item {} 
returns negative value of list length to indicate incorrect length and provide meaningful error message

\item {} 
prints error and exits if a value of the wrong type is found in the list

\item {} 
returns None if successful

\end{itemize}

\end{description}

\end{fulllineitems}

\index{warning() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{warning()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.warning}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{warning}}}{\emph{warnString}, \emph{warningFile=''}}{}
print a warning to a file (currently does not work)

\end{fulllineitems}

\index{zero\_in\_std\_devs() (pydfnworks.dfnGen.gen\_input.input\_helper method)@\spxentry{zero\_in\_std\_devs()}\spxextra{pydfnworks.dfnGen.gen\_input.input\_helper method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_input.input_helper.zero_in_std_devs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{zero\_in\_std\_devs}}}{\emph{valList}}{}
returns True is there is a zero in valList of standard deviations

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{pydfnworks:module-pydfnworks.dfnGen.distributions}}\index{pydfnworks.dfnGen.distributions (module)@\spxentry{pydfnworks.dfnGen.distributions}\spxextra{module}}\index{distr (class in pydfnworks.dfnGen.distributions)@\spxentry{distr}\spxextra{class in pydfnworks.dfnGen.distributions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.distributions.}}\sphinxbfcode{\sphinxupquote{distr}}}{\emph{params}, \emph{numEdistribs}, \emph{numRdistribs}, \emph{minFracSize}}{}
Verifies the fracture distribution input parameters for dfnGen.
\index{params (pydfnworks.dfnGen.distributions.distr attribute)@\spxentry{params}\spxextra{pydfnworks.dfnGen.distributions.distr attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr.params}}\pysigline{\sphinxbfcode{\sphinxupquote{params}}}
list
Parameters for dfnGen

\end{fulllineitems}

\index{numEdistribs (pydfnworks.dfnGen.distributions.distr attribute)@\spxentry{numEdistribs}\spxextra{pydfnworks.dfnGen.distributions.distr attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr.numEdistribs}}\pysigline{\sphinxbfcode{\sphinxupquote{numEdistribs}}}
int
Number of ellipse family distributions

\end{fulllineitems}

\index{numRdistribs (pydfnworks.dfnGen.distributions.distr attribute)@\spxentry{numRdistribs}\spxextra{pydfnworks.dfnGen.distributions.distr attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr.numRdistribs}}\pysigline{\sphinxbfcode{\sphinxupquote{numRdistribs}}}
int
Number of rectangle family distributions

\end{fulllineitems}

\index{minFracSize (pydfnworks.dfnGen.distributions.distr attribute)@\spxentry{minFracSize}\spxextra{pydfnworks.dfnGen.distributions.distr attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr.minFracSize}}\pysigline{\sphinxbfcode{\sphinxupquote{minFracSize}}}
double
Minimum fracture size

\end{fulllineitems}

\index{beta\_distribution() (pydfnworks.dfnGen.distributions.distr method)@\spxentry{beta\_distribution()}\spxextra{pydfnworks.dfnGen.distributions.distr method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr.beta_distribution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{beta\_distribution}}}{\emph{prefix}}{}
Verifies both the “ebetaDistribution” and “rBetaDistribution”. If either contain any flags
indicating contant angle (1) then the corresponding “ebeta” and/or “rbeta” parameters are
also verified.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{prefix}} \textendash{} str
Indicates shapes that the beta distribution describes. ‘e’ if they are ellipses, ‘r’ if they are rectangles.

\end{description}\end{quote}

\end{fulllineitems}

\index{constant\_dist() (pydfnworks.dfnGen.distributions.distr method)@\spxentry{constant\_dist()}\spxextra{pydfnworks.dfnGen.distributions.distr method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr.constant_dist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{constant\_dist}}}{\emph{prefix}}{}
Verifies parameters for constant distribution of fractures

\end{fulllineitems}

\index{distr() (pydfnworks.dfnGen.distributions.distr method)@\spxentry{distr()}\spxextra{pydfnworks.dfnGen.distributions.distr method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr.distr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{distr}}}{\emph{prefix}}{}
Verifies “edistr” and “rdistr” making sure one distribution is defined per family and
each distribution is either 1 (log-normal), 2 (Truncated Power Law), 3 (Exponential), or 4 (constant).
Stores how many of each distrib are in use in numEdistribs or numRdistribs lists.

\end{fulllineitems}

\index{exponential\_dist() (pydfnworks.dfnGen.distributions.distr method)@\spxentry{exponential\_dist()}\spxextra{pydfnworks.dfnGen.distributions.distr method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr.exponential_dist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exponential\_dist}}}{\emph{prefix}}{}
Verifies parameters for exponential distribution of fractures.

\end{fulllineitems}

\index{lognormal\_dist() (pydfnworks.dfnGen.distributions.distr method)@\spxentry{lognormal\_dist()}\spxextra{pydfnworks.dfnGen.distributions.distr method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr.lognormal_dist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{lognormal\_dist}}}{\emph{prefix}}{}
Verifies all logNormal Parameters for ellipses and Rectangles.

\end{fulllineitems}

\index{tpl\_dist() (pydfnworks.dfnGen.distributions.distr method)@\spxentry{tpl\_dist()}\spxextra{pydfnworks.dfnGen.distributions.distr method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.distributions.distr.tpl_dist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tpl\_dist}}}{\emph{prefix}}{}
Verifies parameters for truncated power law distribution of fractures.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Running the generator}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnGen.generator}}\label{\detokenize{pydfnworks:running-the-generator}}\index{pydfnworks.dfnGen.generator (module)@\spxentry{pydfnworks.dfnGen.generator}\spxextra{module}}\index{create\_network() (in module pydfnworks.dfnGen.generator)@\spxentry{create\_network()}\spxextra{in module pydfnworks.dfnGen.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.generator.create_network}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.generator.}}\sphinxbfcode{\sphinxupquote{create\_network}}}{\emph{self}}{}
Execute dfnGen
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

After generation is complete, this script checks whether the generation of the fracture network failed or succeeded based on the existance of the file params.txt.

\end{fulllineitems}

\index{dfn\_gen() (in module pydfnworks.dfnGen.generator)@\spxentry{dfn\_gen()}\spxextra{in module pydfnworks.dfnGen.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.generator.dfn_gen}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.generator.}}\sphinxbfcode{\sphinxupquote{dfn\_gen}}}{\emph{self}, \emph{output=True}, \emph{visual\_mode=None}}{}~\begin{description}
\item[{Wrapper script the runs the dfnGen workflow:}] \leavevmode\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi )}
\makeatletter\def\p@enumii{\p@enumi \theenumi )}\makeatother
\item {} 
make\_working\_directory: Create a directory with name of job

\item {} 
check\_input: Check input parameters and create a clean version of the input file

\item {} 
create\_network: Create network. DFNGEN v2.0 is called and creates the network

\item {} 
output\_report: Generate a PDF summary of the DFN generation

\item {} 
mesh\_network: calls module dfnGen\_meshing and runs LaGriT to mesh the DFN

\end{enumerate}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, output pdf will be created. If False, no pdf is made

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visual\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} If the user wants to run in a different meshing mode from what is in params.txt, set visual\_mode = True/False on command line to override meshing mode

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Details of each portion of the routine are in those sections

\end{fulllineitems}

\index{make\_working\_directory() (in module pydfnworks.dfnGen.generator)@\spxentry{make\_working\_directory()}\spxextra{in module pydfnworks.dfnGen.generator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.generator.make_working_directory}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.generator.}}\sphinxbfcode{\sphinxupquote{make\_working\_directory}}}{\emph{self}}{}
Make working directory for dfnWorks Simulation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class object

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

If directory already exists, user is prompted if they want to overwrite and proceed. If not, program exits.

\end{fulllineitems}



\subsection{Analysis of Generated DFN}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnGen.gen_output}}\label{\detokenize{pydfnworks:analysis-of-generated-dfn}}\index{pydfnworks.dfnGen.gen\_output (module)@\spxentry{pydfnworks.dfnGen.gen\_output}\spxextra{module}}\index{output\_report() (in module pydfnworks.dfnGen.gen\_output)@\spxentry{output\_report()}\spxextra{in module pydfnworks.dfnGen.gen\_output}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.gen_output.output_report}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.gen\_output.}}\sphinxbfcode{\sphinxupquote{output\_report}}}{\emph{self}, \emph{radiiFile='radii.dat'}, \emph{famFile='families.dat'}, \emph{transFile='translations.dat'}, \emph{rejectFile='rejections.dat'}, \emph{output\_name=''}}{}
Create PDF report of generator
\begin{quote}
\begin{description}
\item[{Notes:}] \leavevmode\begin{itemize}
\item {} 
Set the number of histogram buckets (bins) by changing numBuckets variable in his graphing functions

\item {} 
Also change number of x-values used to plot lines by changing numXpoints variable in appropriate funcs

\item {} 
Set show = True to show plots immediately and still make pdf

\item {} 
NOTE future developers of this code should add functionality for radiiList of size 0.

\end{itemize}

\end{description}
\end{quote}

\end{fulllineitems}



\section{Meshing - LaGriT}
\label{\detokenize{pydfnworks:meshing-lagrit}}

\subsection{Mesh DFN}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnGen.mesh_dfn}}\label{\detokenize{pydfnworks:mesh-dfn}}\index{pydfnworks.dfnGen.mesh\_dfn (module)@\spxentry{pydfnworks.dfnGen.mesh\_dfn}\spxextra{module}}\phantomsection\label{\detokenize{pydfnworks:module-mesh_dfn.py}}\index{mesh\_dfn.py (module)@\spxentry{mesh\_dfn.py}\spxextra{module}}\index{mesh\_network() (in module pydfnworks.dfnGen.mesh\_dfn)@\spxentry{mesh\_network()}\spxextra{in module pydfnworks.dfnGen.mesh\_dfn}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.mesh_dfn.mesh_network}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.mesh\_dfn.}}\sphinxbfcode{\sphinxupquote{mesh\_network}}}{\emph{self}, \emph{prune=False}, \emph{uniform\_mesh=False}, \emph{production\_mode=True}, \emph{refine\_factor=1}, \emph{slope=2}, \emph{visual\_mode=None}}{}
Mesh fracture network using LaGriT
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prune}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If prune is False, mesh entire network. If prune is True, mesh only fractures in self.prune\_file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uniform\_mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, mesh is uniform resolution. If False, mesh is spatially variable

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{production\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, all working files while meshing are cleaned up. If False, then working files will not be deleted

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refine\_factor}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Determines distance for mesh refinement (default=1)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{slope}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Slope of piecewise linear function determining rate of coarsening.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visual\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} If the user wants to run in a different meshing mode from what is in params.txt, set visual\_mode = True/False on command line to override meshing mode

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
For uniform resolution mesh, set slope = 0

\item {} 
All fractures in self.prune\_file must intersect at least 1 other fracture

\end{enumerate}

\end{fulllineitems}



\subsection{LaGrit scripts}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnGen.lagrit_scripts}}\label{\detokenize{pydfnworks:lagrit-scripts}}\index{pydfnworks.dfnGen.lagrit\_scripts (module)@\spxentry{pydfnworks.dfnGen.lagrit\_scripts}\spxextra{module}}\phantomsection\label{\detokenize{pydfnworks:module-lagrit_scripts.py}}\index{lagrit\_scripts.py (module)@\spxentry{lagrit\_scripts.py}\spxextra{module}}\index{create\_lagrit\_scripts() (in module pydfnworks.dfnGen.lagrit\_scripts)@\spxentry{create\_lagrit\_scripts()}\spxextra{in module pydfnworks.dfnGen.lagrit\_scripts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.lagrit_scripts.create_lagrit_scripts}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.lagrit\_scripts.}}\sphinxbfcode{\sphinxupquote{create\_lagrit\_scripts}}}{\emph{visual\_mode}, \emph{ncpu}, \emph{refine\_factor=1}, \emph{production\_mode=True}}{}
Creates LaGriT script to be mesh each polygon
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visual\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Sets if running if visual mode or in full dump

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ncpu}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of cpus

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refine\_factor}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of times original polygon gets refined

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{production\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Determines if clean up of work files occurs on the fly.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Only ncpu of these files are created

\item {} 
Symbolic links are used to rotate through fractures on different CPUs

\end{enumerate}

\end{fulllineitems}

\index{create\_merge\_poly\_files() (in module pydfnworks.dfnGen.lagrit\_scripts)@\spxentry{create\_merge\_poly\_files()}\spxextra{in module pydfnworks.dfnGen.lagrit\_scripts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.lagrit_scripts.create_merge_poly_files}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.lagrit\_scripts.}}\sphinxbfcode{\sphinxupquote{create\_merge\_poly\_files}}}{\emph{ncpu}, \emph{num\_poly}, \emph{fracture\_list}, \emph{h}, \emph{visual\_mode}, \emph{domain}, \emph{flow\_solver}}{}
Creates a LaGriT script that reads in each fracture mesh, appends it to the main mesh, and then deletes that mesh object. Then duplicate points are removed from the main mesh using EPS\_FILTER.  The points are compressed, and then written to file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ncpu}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of Processors used for meshing

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fracture\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}) \textendash{} List of fracture numbers in the DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Meshing length scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visual\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, reduced\_mesh.inp will be output. If False, full\_mesh.inp is output

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domain}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary of x,y,z domain size

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{flow\_solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of target flow solver (Changes output files)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{n\_jobs} \textendash{} number of merge jobs

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Fracture mesh objects are read into different part\_*.lg files. This allows for merging of the mesh to be performed in batches.

\end{enumerate}

\end{fulllineitems}

\index{create\_parameter\_mlgi\_file() (in module pydfnworks.dfnGen.lagrit\_scripts)@\spxentry{create\_parameter\_mlgi\_file()}\spxextra{in module pydfnworks.dfnGen.lagrit\_scripts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.lagrit_scripts.create_parameter_mlgi_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.lagrit\_scripts.}}\sphinxbfcode{\sphinxupquote{create\_parameter\_mlgi\_file}}}{\emph{fracture\_list}, \emph{h}, \emph{slope=2.0}, \emph{refine\_dist=0.5}}{}
Create parameteri.mlgi files used in running LaGriT Scripts
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_poly}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of polygons

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Meshing length scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{slope}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Slope of coarsening function, default = 2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refine\_dist}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Distance used in coarsening function, default = 0.5

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Set slope = 0 for uniform mesh

\end{fulllineitems}

\index{create\_user\_functions() (in module pydfnworks.dfnGen.lagrit\_scripts)@\spxentry{create\_user\_functions()}\spxextra{in module pydfnworks.dfnGen.lagrit\_scripts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.lagrit_scripts.create_user_functions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.lagrit\_scripts.}}\sphinxbfcode{\sphinxupquote{create\_user\_functions}}}{}{}
Create user\_function.lgi files for meshing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{None}} \textendash{} 

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

These functions are called within LaGriT. It controls the mesh resolution using slope and refine\_dist

\end{fulllineitems}

\index{define\_zones() (in module pydfnworks.dfnGen.lagrit\_scripts)@\spxentry{define\_zones()}\spxextra{in module pydfnworks.dfnGen.lagrit\_scripts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.lagrit_scripts.define_zones}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.lagrit\_scripts.}}\sphinxbfcode{\sphinxupquote{define\_zones}}}{}{}
Processes zone files for particle tracking. All zone files are combined into allboundaries.zone
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{None}} \textendash{} 

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}

\index{edit\_intersection\_files() (in module pydfnworks.dfnGen.lagrit\_scripts)@\spxentry{edit\_intersection\_files()}\spxextra{in module pydfnworks.dfnGen.lagrit\_scripts}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.lagrit_scripts.edit_intersection_files}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.lagrit\_scripts.}}\sphinxbfcode{\sphinxupquote{edit\_intersection\_files}}}{\emph{num\_poly}, \emph{fracture\_list}, \emph{path}}{}
If pruning a DFN, this function walks through the intersection files
and removes references to files that are not included in the
fractures that will remain in the network.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_poly}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of Fractures in the original DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fracture\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}) \textendash{} List of fractures to keep in the DFN

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Currently running in serial, but it could be parallelized

\item {} 
Assumes the pruning directory is not the original directory

\end{enumerate}

\end{fulllineitems}



\subsection{Run meshing in parallel}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnGen.run_meshing}}\label{\detokenize{pydfnworks:run-meshing-in-parallel}}\index{pydfnworks.dfnGen.run\_meshing (module)@\spxentry{pydfnworks.dfnGen.run\_meshing}\spxextra{module}}\phantomsection\label{\detokenize{pydfnworks:module-run_meshing.py}}\index{run\_meshing.py (module)@\spxentry{run\_meshing.py}\spxextra{module}}\index{merge\_the\_meshes() (in module pydfnworks.dfnGen.run\_meshing)@\spxentry{merge\_the\_meshes()}\spxextra{in module pydfnworks.dfnGen.run\_meshing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.run_meshing.merge_the_meshes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.run\_meshing.}}\sphinxbfcode{\sphinxupquote{merge\_the\_meshes}}}{\emph{num\_poly}, \emph{ncpu}, \emph{n\_jobs}, \emph{visual\_mode}}{}
Runs the LaGrit Scripts to merge meshes into final mesh
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_poly}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of Fractures

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ncpu}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of Processors

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_jobs}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of mesh pieces

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visual\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} True/False for reduced meshing

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Meshes are merged in batches for efficiency

\end{fulllineitems}

\index{merge\_worker() (in module pydfnworks.dfnGen.run\_meshing)@\spxentry{merge\_worker()}\spxextra{in module pydfnworks.dfnGen.run\_meshing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.run_meshing.merge_worker}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.run\_meshing.}}\sphinxbfcode{\sphinxupquote{merge\_worker}}}{\emph{job}}{}
Parallel worker for merge meshes into final mesh
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{job}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} job number

\item[{Returns}] \leavevmode
\sphinxstylestrong{bool}

\item[{Return type}] \leavevmode
True if failed / False if successful

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{mesh\_fracture() (in module pydfnworks.dfnGen.run\_meshing)@\spxentry{mesh\_fracture()}\spxextra{in module pydfnworks.dfnGen.run\_meshing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.run_meshing.mesh_fracture}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.run\_meshing.}}\sphinxbfcode{\sphinxupquote{mesh\_fracture}}}{\emph{fracture\_id}, \emph{visual\_mode}, \emph{num\_poly}}{}
Child function for parallelized meshing of fractures
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fracture\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Current Fracture ID number

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visual\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} True/False for reduced meshing

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_poly}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Total Number of Fractures in the DFN

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

If meshing fails, information about that fracture will be put into a directory failure\_(fracture\_id)

\end{fulllineitems}

\index{mesh\_fractures\_header() (in module pydfnworks.dfnGen.run\_meshing)@\spxentry{mesh\_fractures\_header()}\spxextra{in module pydfnworks.dfnGen.run\_meshing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.run_meshing.mesh_fractures_header}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.run\_meshing.}}\sphinxbfcode{\sphinxupquote{mesh\_fractures\_header}}}{\emph{fracture\_list}, \emph{ncpu}, \emph{visual\_mode}}{}
Header function for Parallel meshing of fractures

Creates a queue of fracture numbers ranging from 1, num\_poly

Each fractures is meshed using mesh\_fracture called within the
worker function.

If any fracture fails to mesh properly, then a folder is created with
that fracture information and the fracture number is written into
failure.txt.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fracture\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Fractures to be meshed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visual\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} True/False for reduced meshing

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_poly}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Total Number of Fractures

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{True/False} \textendash{} True - If failure.txt is empty then all fractures have been meshed correctly
False - If failure.txt is not empty, then at least one fracture failed.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}
\subsubsection*{Notes}

If one fracture fails meshing, program will exit.

\end{fulllineitems}

\index{single\_worker() (in module pydfnworks.dfnGen.run\_meshing)@\spxentry{single\_worker()}\spxextra{in module pydfnworks.dfnGen.run\_meshing}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.run_meshing.single_worker}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.run\_meshing.}}\sphinxbfcode{\sphinxupquote{single\_worker}}}{\emph{work\_queue}, \emph{visual\_mode}, \emph{num\_poly}}{}
Worker function for parallelized meshing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{work\_queue}} (\sphinxstyleliteralemphasis{\sphinxupquote{multiprocessing queue}}) \textendash{} Queue of fractures to be meshed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visual\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} True/False for reduced meshing

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_poly}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Total Number of Fractures

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{True} \textendash{} If job is complete

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Mesh helper methods}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnGen.mesh_dfn_helper}}\label{\detokenize{pydfnworks:mesh-helper-methods}}\index{pydfnworks.dfnGen.mesh\_dfn\_helper (module)@\spxentry{pydfnworks.dfnGen.mesh\_dfn\_helper}\spxextra{module}}\phantomsection\label{\detokenize{pydfnworks:module-mesh_dfn_helper.py}}\index{mesh\_dfn\_helper.py (module)@\spxentry{mesh\_dfn\_helper.py}\spxextra{module}}\index{check\_dudded\_points() (in module pydfnworks.dfnGen.mesh\_dfn\_helper)@\spxentry{check\_dudded\_points()}\spxextra{in module pydfnworks.dfnGen.mesh\_dfn\_helper}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.mesh_dfn_helper.check_dudded_points}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.mesh\_dfn\_helper.}}\sphinxbfcode{\sphinxupquote{check\_dudded\_points}}}{\emph{dudded}, \emph{hard=False}}{}
Parses LaGrit log\_merge\_all.txt and checks if number of dudded points is the expected number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dudded}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Expected number of dudded points from params.txt

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hard}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If hard is false, up to 1\% of nodes in the mesh can be missed. If hard is True, no points can be missed.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{True/False} \textendash{} True if the number of dudded points is correct and  False if the number of dudded points is incorrect

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}
\subsubsection*{Notes}

If number of dudded points is incorrect by over 1\%, program will exit.

\end{fulllineitems}

\index{clean\_up\_files\_after\_prune() (in module pydfnworks.dfnGen.mesh\_dfn\_helper)@\spxentry{clean\_up\_files\_after\_prune()}\spxextra{in module pydfnworks.dfnGen.mesh\_dfn\_helper}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.mesh_dfn_helper.clean_up_files_after_prune}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.mesh\_dfn\_helper.}}\sphinxbfcode{\sphinxupquote{clean\_up\_files\_after\_prune}}}{\emph{self}}{}
After pruning a DFN to only include the fractures in prune\_file this function removes references to those fractures from params.txt, perm.dat, aperature.dat, and poly\_info.dat
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prune\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name for file with list of fractures to remain in the network

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Path to files to be modified

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

This function should always be run after pruning if flow solution is going to be run

\end{fulllineitems}

\index{cleanup\_dir() (in module pydfnworks.dfnGen.mesh\_dfn\_helper)@\spxentry{cleanup\_dir()}\spxextra{in module pydfnworks.dfnGen.mesh\_dfn\_helper}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.mesh_dfn_helper.cleanup_dir}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.mesh\_dfn\_helper.}}\sphinxbfcode{\sphinxupquote{cleanup\_dir}}}{}{}
Removes meshing files
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{None}} \textendash{} 

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Only runs if production\_mode is True

\end{fulllineitems}

\index{create\_mesh\_links() (in module pydfnworks.dfnGen.mesh\_dfn\_helper)@\spxentry{create\_mesh\_links()}\spxextra{in module pydfnworks.dfnGen.mesh\_dfn\_helper}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.mesh_dfn_helper.create_mesh_links}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.mesh\_dfn\_helper.}}\sphinxbfcode{\sphinxupquote{create\_mesh\_links}}}{\emph{path}}{}
Makes symlinks for files in path required for meshing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Path to where meshing files are located

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}

\index{inp2gmv() (in module pydfnworks.dfnGen.mesh\_dfn\_helper)@\spxentry{inp2gmv()}\spxextra{in module pydfnworks.dfnGen.mesh\_dfn\_helper}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.mesh_dfn_helper.inp2gmv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.mesh\_dfn\_helper.}}\sphinxbfcode{\sphinxupquote{inp2gmv}}}{\emph{self}, \emph{inp\_file=''}}{}
Convert inp file to gmv file, for general mesh viewer. Name of output file for base.inp is base.gmv
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inp\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of inp file if not an attribure of self

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{output\_meshing\_report() (in module pydfnworks.dfnGen.mesh\_dfn\_helper)@\spxentry{output\_meshing\_report()}\spxextra{in module pydfnworks.dfnGen.mesh\_dfn\_helper}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.mesh_dfn_helper.output_meshing_report}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.mesh\_dfn\_helper.}}\sphinxbfcode{\sphinxupquote{output\_meshing\_report}}}{\emph{local\_jobname}, \emph{visual\_mode}}{}
Prints information about the final mesh to file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{local\_jobname}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of current DFN job (not path)

\end{description}\end{quote}
\begin{description}
\item[{visual\_mode}] \leavevmode{[}bool{]}
Determines is reduced\_mesh or full\_mesh is dumped

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}

\index{parse\_params\_file() (in module pydfnworks.dfnGen.mesh\_dfn\_helper)@\spxentry{parse\_params\_file()}\spxextra{in module pydfnworks.dfnGen.mesh\_dfn\_helper}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGen.mesh_dfn_helper.parse_params_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGen.mesh\_dfn\_helper.}}\sphinxbfcode{\sphinxupquote{parse\_params\_file}}}{\emph{quite=False}}{}
Reads params.txt file from DFNGen and parses information
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{quite}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True details are not printed to screen, if False they area

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{num\_poly} (\sphinxstyleemphasis{int}) \textendash{} Number of Polygons

\item {} 
\sphinxstylestrong{h} (\sphinxstyleemphasis{float}) \textendash{} Meshing length scale h

\item {} 
\sphinxstylestrong{dudded\_points} (\sphinxstyleemphasis{int}) \textendash{} Expected number of dudded points in Filter (LaGriT)

\item {} 
\sphinxstylestrong{visual\_mode} (\sphinxstyleemphasis{bool}) \textendash{} If True, reduced\_mesh.inp is created (not suitable for flow and transport), if False, full\_mesh.inp is created

\item {} 
\sphinxstylestrong{domain} (\sphinxstyleemphasis{dict}) \textendash{} x,y,z domain sizes

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}



\section{dfnFlow}
\label{\detokenize{pydfnworks:dfnflow}}

\subsection{Running Flow}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnFlow.flow}}\label{\detokenize{pydfnworks:running-flow}}\index{pydfnworks.dfnFlow.flow (module)@\spxentry{pydfnworks.dfnFlow.flow}\spxextra{module}}\index{create\_dfn\_flow\_links() (in module pydfnworks.dfnFlow.flow)@\spxentry{create\_dfn\_flow\_links()}\spxextra{in module pydfnworks.dfnFlow.flow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.flow.create_dfn_flow_links}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.flow.}}\sphinxbfcode{\sphinxupquote{create\_dfn\_flow\_links}}}{\emph{self}, \emph{path='../'}}{}
Create symlinks to files required to run dfnFlow that are in another directory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Absolute path to primary directory.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Typically, the path is DFN.path, which is set by the command line argument -path

\item {} 
Currently only supported for PFLOTRAN

\end{enumerate}

\end{fulllineitems}

\index{dfn\_flow() (in module pydfnworks.dfnFlow.flow)@\spxentry{dfn\_flow()}\spxextra{in module pydfnworks.dfnFlow.flow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.flow.dfn_flow}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.flow.}}\sphinxbfcode{\sphinxupquote{dfn\_flow}}}{\emph{self}, \emph{dump\_vtk=True}, \emph{effective\_perm=True}}{}
Run the dfnFlow portion of the workflow
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dump\_vtk}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} True - Write out vtk files for flow solutions
False  - Does not write out vtk files for flow solutions

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Information on individual functions is found therein

\end{fulllineitems}

\index{set\_flow\_solver() (in module pydfnworks.dfnFlow.flow)@\spxentry{set\_flow\_solver()}\spxextra{in module pydfnworks.dfnFlow.flow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.flow.set_flow_solver}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.flow.}}\sphinxbfcode{\sphinxupquote{set\_flow\_solver}}}{\emph{self}, \emph{flow\_solver}}{}
Sets flow solver to be used
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{flow\_solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of flow solver. Currently supported flow sovlers are FEHM and PFLOTRAN

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Default is PFLOTRAN

\end{fulllineitems}

\index{uncorrelated() (in module pydfnworks.dfnFlow.flow)@\spxentry{uncorrelated()}\spxextra{in module pydfnworks.dfnFlow.flow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.flow.uncorrelated}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.flow.}}\sphinxbfcode{\sphinxupquote{uncorrelated}}}{\emph{self}, \emph{mu}, \emph{sigma}, \emph{path='../'}}{}
Creates Fracture Based Log-Normal Permeability field with mean mu and variance sigma. Aperture is dervived using the cubic law
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mu}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Mean of LogNormal Permeability field

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigma}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Variance of permeability field

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} path to original network. Can be current directory

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

mu is the mean of perm not log(perm)

\end{fulllineitems}



\subsection{Running Flow: PFLOTRAN}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnFlow.pflotran}}\label{\detokenize{pydfnworks:running-flow-pflotran}}\index{pydfnworks.dfnFlow.pflotran (module)@\spxentry{pydfnworks.dfnFlow.pflotran}\spxextra{module}}
functions for using pflotran in dfnworks
\index{check\_pflotran\_convergence() (in module pydfnworks.dfnFlow.pflotran)@\spxentry{check\_pflotran\_convergence()}\spxextra{in module pydfnworks.dfnFlow.pflotran}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.pflotran.check_pflotran_convergence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.pflotran.}}\sphinxbfcode{\sphinxupquote{check\_pflotran\_convergence}}}{\emph{pflotran\_input\_file}}{}
checks pflotran\_input\_file.out for convergence
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{pflotran\_input\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} pflotran\_input\_file

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstyleemphasis{bool}

\item {} 
\sphinxstyleemphasis{True if solver converged / False if not}

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{inp2vtk\_python() (in module pydfnworks.dfnFlow.pflotran)@\spxentry{inp2vtk\_python()}\spxextra{in module pydfnworks.dfnFlow.pflotran}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.pflotran.inp2vtk_python}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.pflotran.}}\sphinxbfcode{\sphinxupquote{inp2vtk\_python}}}{\emph{self}}{}
Using Python VTK library, convert inp file to VTK file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

For a mesh base.inp, this dumps a VTK file named base.vtk

\end{fulllineitems}

\index{lagrit2pflotran() (in module pydfnworks.dfnFlow.pflotran)@\spxentry{lagrit2pflotran()}\spxextra{in module pydfnworks.dfnFlow.pflotran}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.pflotran.lagrit2pflotran}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.pflotran.}}\sphinxbfcode{\sphinxupquote{lagrit2pflotran}}}{\emph{self}, \emph{inp\_file=''}, \emph{mesh\_type=''}, \emph{hex2tet=False}}{}
Takes output from LaGriT and processes it for use in PFLOTRAN.
Calls the functuon write\_perms\_and\_correct\_volumes\_areas() and zone2ex
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inp\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the inp (AVS) file produced by LaGriT

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mesh\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The type of mesh

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hex2tet}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} True if hex mesh elements should be converted to tet elements, False otherwise.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}

\index{parse\_pflotran\_vtk\_python() (in module pydfnworks.dfnFlow.pflotran)@\spxentry{parse\_pflotran\_vtk\_python()}\spxextra{in module pydfnworks.dfnFlow.pflotran}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.pflotran.parse_pflotran_vtk_python}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.pflotran.}}\sphinxbfcode{\sphinxupquote{parse\_pflotran\_vtk\_python}}}{\emph{self}, \emph{grid\_vtk\_file=''}}{}
Replace CELL\_DATA with POINT\_DATA in the VTK output.
:param self: DFN Class
:type self: object
:param grid\_vtk\_file: Name of vtk file with mesh. Typically local\_dfnFlow\_file.vtk
:type grid\_vtk\_file: string
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

If DFN class does not have a vtk file, inp2vtk\_python is called

\end{fulllineitems}

\index{pflotran() (in module pydfnworks.dfnFlow.pflotran)@\spxentry{pflotran()}\spxextra{in module pydfnworks.dfnFlow.pflotran}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.pflotran.pflotran}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.pflotran.}}\sphinxbfcode{\sphinxupquote{pflotran}}}{\emph{self}, \emph{restart=False}, \emph{restart\_file=''}}{}
Run PFLOTRAN. Copy PFLOTRAN run file into working directory and run with ncpus
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Runs PFLOTRAN Executable, see \sphinxurl{http://www.pflotran.org/} for details on PFLOTRAN input cards

\end{fulllineitems}

\index{pflotran\_cleanup() (in module pydfnworks.dfnFlow.pflotran)@\spxentry{pflotran\_cleanup()}\spxextra{in module pydfnworks.dfnFlow.pflotran}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.pflotran.pflotran_cleanup}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.pflotran.}}\sphinxbfcode{\sphinxupquote{pflotran\_cleanup}}}{\emph{self}, \emph{index\_start=0}, \emph{index\_finish=1}, \emph{filename=''}}{}
Concatenate PFLOTRAN output files and then delete them
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} If PFLOTRAN has multiple dumps use this to pick which dump is put into cellinfo.dat and darcyvel.dat

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Can be run in a loop over all pflotran dumps

\end{fulllineitems}

\index{write\_perms\_and\_correct\_volumes\_areas() (in module pydfnworks.dfnFlow.pflotran)@\spxentry{write\_perms\_and\_correct\_volumes\_areas()}\spxextra{in module pydfnworks.dfnFlow.pflotran}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.pflotran.write_perms_and_correct_volumes_areas}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.pflotran.}}\sphinxbfcode{\sphinxupquote{write\_perms\_and\_correct\_volumes\_areas}}}{\emph{self}}{}
Write permeability values to perm\_file, write aperture values to aper\_file, and correct volume areas in uge\_file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Calls executable correct\_uge

\end{fulllineitems}

\index{zone2ex() (in module pydfnworks.dfnFlow.pflotran)@\spxentry{zone2ex()}\spxextra{in module pydfnworks.dfnFlow.pflotran}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.pflotran.zone2ex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.pflotran.}}\sphinxbfcode{\sphinxupquote{zone2ex}}}{\emph{self}, \emph{uge\_file=''}, \emph{zone\_file=''}, \emph{face=''}, \emph{boundary\_cell\_area=0.1}}{}
Convert zone files from LaGriT into ex format for LaGriT
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uge\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of uge file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of zone file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Face}} (\sphinxstyleliteralemphasis{\sphinxupquote{Face of the plane corresponding to the zone file}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zone\_file}} \textendash{} Name of zone file to work on. Can be ‘all’ processes all directions, top, bottom, left, right, front, back

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{boundary\_cell\_area}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Boundary cells are moved a distance of boundary\_cell\_area 1e-1

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

the boundary\_cell\_area should be a function of h, the mesh resolution

\end{fulllineitems}



\subsection{Running Flow: FEHM}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnFlow.fehm}}\label{\detokenize{pydfnworks:running-flow-fehm}}\index{pydfnworks.dfnFlow.fehm (module)@\spxentry{pydfnworks.dfnFlow.fehm}\spxextra{module}}\index{correct\_perm\_for\_fehm() (in module pydfnworks.dfnFlow.fehm)@\spxentry{correct\_perm\_for\_fehm()}\spxextra{in module pydfnworks.dfnFlow.fehm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.fehm.correct_perm_for_fehm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.fehm.}}\sphinxbfcode{\sphinxupquote{correct\_perm\_for\_fehm}}}{}{}
FEHM wants an empty line at the end of the perm file
This functions adds that line return
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{None}} \textendash{} 

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Only adds a new line if the last line is not empty

\end{fulllineitems}

\index{correct\_stor\_file() (in module pydfnworks.dfnFlow.fehm)@\spxentry{correct\_stor\_file()}\spxextra{in module pydfnworks.dfnFlow.fehm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.fehm.correct_stor_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.fehm.}}\sphinxbfcode{\sphinxupquote{correct\_stor\_file}}}{\emph{self}}{}
Corrects volumes in stor file to account for apertures
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Currently does not work with cell based aperture

\end{fulllineitems}

\index{fehm() (in module pydfnworks.dfnFlow.fehm)@\spxentry{fehm()}\spxextra{in module pydfnworks.dfnFlow.fehm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.fehm.fehm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.fehm.}}\sphinxbfcode{\sphinxupquote{fehm}}}{\emph{self}}{}
Run FEHM
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

See \sphinxurl{https://fehm.lanl.gov/} for details about FEHM

\end{fulllineitems}



\subsection{Processing Flow}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnFlow.mass_balance}}\label{\detokenize{pydfnworks:processing-flow}}\index{pydfnworks.dfnFlow.mass\_balance (module)@\spxentry{pydfnworks.dfnFlow.mass\_balance}\spxextra{module}}\index{dump\_effective\_perm() (in module pydfnworks.dfnFlow.mass\_balance)@\spxentry{dump\_effective\_perm()}\spxextra{in module pydfnworks.dfnFlow.mass\_balance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.mass_balance.dump_effective_perm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.mass\_balance.}}\sphinxbfcode{\sphinxupquote{dump\_effective\_perm}}}{\emph{local\_jobname}, \emph{mass\_rate}, \emph{volume\_rate}, \emph{domain}, \emph{direction}, \emph{inflow\_pressure}, \emph{outflow\_pressure}}{}
Compute the effective permeability of the DFN and write it to screen and to the file local\_jobname\_effective\_perm.dat
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{local\_jobname}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Jobname

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mass\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Mass flow rate through inflow boundary

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{volume\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Volumetric flow rate through inflow boundary

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{direction}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Primary direction of flow (x, y, or z)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{domain}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary of domain sizes in x, y, z

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inflow\_pressure}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Inflow boundary pressure

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outflow\_pressure}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Outflow boundary pressure

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Information is written into (local\_jobname)\_effective\_perm.txt

\end{fulllineitems}

\index{effective\_perm() (in module pydfnworks.dfnFlow.mass\_balance)@\spxentry{effective\_perm()}\spxextra{in module pydfnworks.dfnFlow.mass\_balance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.mass_balance.effective_perm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.mass\_balance.}}\sphinxbfcode{\sphinxupquote{effective\_perm}}}{\emph{self}}{}
Computes the effective permeability of a DFN in the primary direction of flow using a steady-state PFLOTRAN solution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Information is written to screen and to the file self.local\_jobname\_effective\_perm.txt

\item {} 
Currently, only PFLOTRAN solutions are supported

\item {} 
Assumes density of water

\end{enumerate}

\end{fulllineitems}

\index{flow\_rate() (in module pydfnworks.dfnFlow.mass\_balance)@\spxentry{flow\_rate()}\spxextra{in module pydfnworks.dfnFlow.mass\_balance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.mass_balance.flow_rate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.mass\_balance.}}\sphinxbfcode{\sphinxupquote{flow\_rate}}}{\emph{darcy\_vel\_file}, \emph{boundary\_file}}{}
Calculates the flow rate across the inflow boundary
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{darcy\_vel\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of concatenated Darcy velocity file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{boundary\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} ex file for the inflow boundary

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{mass\_rate} (\sphinxstyleemphasis{float}) \textendash{} Mass flow rate across the inflow boundary

\item {} 
\sphinxstylestrong{volume\_rate} (\sphinxstyleemphasis{float}) \textendash{} Volumetric flow rate across the inflow boundary

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}

\index{get\_domain() (in module pydfnworks.dfnFlow.mass\_balance)@\spxentry{get\_domain()}\spxextra{in module pydfnworks.dfnFlow.mass\_balance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.mass_balance.get_domain}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.mass\_balance.}}\sphinxbfcode{\sphinxupquote{get\_domain}}}{}{}
Return dictionary of domain x,y,z by calling parse\_params\_file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{None}} \textendash{} 

\item[{Returns}] \leavevmode
\sphinxstylestrong{domain} \textendash{} Dictionary of domain sizes in x, y, z

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}
\subsubsection*{Notes}

parse\_params\_file() is in mesh\_dfn\_helper.py

\end{fulllineitems}

\index{parse\_pflotran\_input() (in module pydfnworks.dfnFlow.mass\_balance)@\spxentry{parse\_pflotran\_input()}\spxextra{in module pydfnworks.dfnFlow.mass\_balance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnFlow.mass_balance.parse_pflotran_input}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnFlow.mass\_balance.}}\sphinxbfcode{\sphinxupquote{parse\_pflotran\_input}}}{\emph{pflotran\_input\_file}}{}
Walk through PFLOTRAN input file and find inflow boundary, inflow and outflow pressure, and direction of flow
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{pflotran\_input\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of PFLOTRAN input file

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{inflow\_pressure} (\sphinxstyleemphasis{double}) \textendash{} Inflow Pressure boundary condition

\item {} 
\sphinxstylestrong{outflow\_pressure} (\sphinxstyleemphasis{float}) \textendash{} Outflow pressure boundary condition

\item {} 
\sphinxstylestrong{inflow\_file} (\sphinxstyleemphasis{string}) \textendash{} Name of inflow boundary .ex file

\item {} 
\sphinxstylestrong{direction} (\sphinxstyleemphasis{string}) \textendash{} Primary direction of flow x, y, or z

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

Currently only works for Dirichlet Boundary Conditions

\end{fulllineitems}



\section{dfnTrans}
\label{\detokenize{pydfnworks:dfntrans}}

\subsection{Running Transport}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnTrans.transport}}\label{\detokenize{pydfnworks:running-transport}}\index{pydfnworks.dfnTrans.transport (module)@\spxentry{pydfnworks.dfnTrans.transport}\spxextra{module}}\index{check\_dfn\_trans\_run\_files() (in module pydfnworks.dfnTrans.transport)@\spxentry{check\_dfn\_trans\_run\_files()}\spxextra{in module pydfnworks.dfnTrans.transport}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnTrans.transport.check_dfn_trans_run_files}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnTrans.transport.}}\sphinxbfcode{\sphinxupquote{check\_dfn\_trans\_run\_files}}}{\emph{self}}{}
Ensures that all files required for dfnTrans run are in the current directory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}

\index{copy\_dfn\_trans\_files() (in module pydfnworks.dfnTrans.transport)@\spxentry{copy\_dfn\_trans\_files()}\spxextra{in module pydfnworks.dfnTrans.transport}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnTrans.transport.copy_dfn_trans_files}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnTrans.transport.}}\sphinxbfcode{\sphinxupquote{copy\_dfn\_trans\_files}}}{\emph{self}}{}
Creates symlink to dfnTrans Execuateble and copies input files for dfnTrans into working directory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_dfn\_trans\_links() (in module pydfnworks.dfnTrans.transport)@\spxentry{create\_dfn\_trans\_links()}\spxextra{in module pydfnworks.dfnTrans.transport}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnTrans.transport.create_dfn_trans_links}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnTrans.transport.}}\sphinxbfcode{\sphinxupquote{create\_dfn\_trans\_links}}}{\emph{self}, \emph{path='../'}}{}
Create symlinks to files required to run dfnTrans that are in another directory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Absolute path to primary directory.

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Typically, the path is DFN.path, which is set by the command line argument -path

\end{fulllineitems}

\index{dfn\_trans() (in module pydfnworks.dfnTrans.transport)@\spxentry{dfn\_trans()}\spxextra{in module pydfnworks.dfnTrans.transport}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnTrans.transport.dfn_trans}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnTrans.transport.}}\sphinxbfcode{\sphinxupquote{dfn\_trans}}}{\emph{self}}{}
Primary driver for dfnTrans.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_dfn\_trans() (in module pydfnworks.dfnTrans.transport)@\spxentry{run\_dfn\_trans()}\spxextra{in module pydfnworks.dfnTrans.transport}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnTrans.transport.run_dfn_trans}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnTrans.transport.}}\sphinxbfcode{\sphinxupquote{run\_dfn\_trans}}}{\emph{self}}{}
Execute dfnTrans
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}



\section{dfnGraph}
\label{\detokenize{pydfnworks:dfngraph}}

\subsection{General Graph Functions}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnGraph.dfn2graph}}\label{\detokenize{pydfnworks:general-graph-functions}}\index{pydfnworks.dfnGraph.dfn2graph (module)@\spxentry{pydfnworks.dfnGraph.dfn2graph}\spxextra{module}}\index{add\_area() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{add\_area()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.add_area}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{add\_area}}}{\emph{G}}{}
Read Fracture aperture from fracture\_info.dat and
load on the edges in the graph. Graph must be intersection to node
representation

\end{fulllineitems}

\index{add\_perm() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{add\_perm()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.add_perm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{add\_perm}}}{\emph{G}}{}
Add fracture permeability to Graph. If Graph representation is
fracture, then permeability is a node attribute. If graph representation
is intersection, then permeability is an edge attribute
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{networkX graph}}) \textendash{} NetworkX Graph based on the DFN

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{add\_weight() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{add\_weight()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.add_weight}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{add\_weight}}}{\emph{G}}{}
Compute weight w = K*A/L associated with each edge

\end{fulllineitems}

\index{boundary\_index() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{boundary\_index()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.boundary_index}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{boundary\_index}}}{\emph{bc\_name}}{}
Determines boundary index in intersections\_list.dat from name
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{bc\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Boundary condition name

\item[{Returns}] \leavevmode
\sphinxstylestrong{bc\_index} \textendash{} integer indexing of cube faces

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}
\subsubsection*{Notes}

top = 1
bottom = 2
left = 3
front = 4
right = 5
back = 6

\end{fulllineitems}

\index{create\_bipartite\_graph() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{create\_bipartite\_graph()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.create_bipartite_graph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{create\_bipartite\_graph}}}{\emph{inflow}, \emph{outflow}, \emph{intersection\_list='intersection\_list.dat'}, \emph{fracture\_info='fracture\_info.dat'}}{}
Creates a bipartite graph of the DFN.
Nodes are in two sets, fractures and intersections, with edges connecting them.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of inflow boundary

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of outflow boundary

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{intersection\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} filename of intersections generated from DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fracture\_infor}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} filename for fracture information

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{B}

\item[{Return type}] \leavevmode
NetworkX Graph

\end{description}\end{quote}
\subsubsection*{Notes}

See Hyman et al. 2018 “Identifying Backbones in Three-Dimensional Discrete Fracture Networks: A Bipartite Graph-Based Approach” SIAM Multiscale Modeling and Simulation for more details

\end{fulllineitems}

\index{create\_fracture\_graph() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{create\_fracture\_graph()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.create_fracture_graph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{create\_fracture\_graph}}}{\emph{inflow}, \emph{outflow}, \emph{topology\_file='connectivity.dat'}}{}
Create a graph based on topology of network. Fractures
are represented as nodes and if two fractures intersect
there is an edge between them in the graph.

Source and Target node are added to the graph.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of inflow boundary (connect to source)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of outflow boundary (connect to target)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{topology\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of adjacency matrix file for a DFN default=connectivity.dat

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{G} \textendash{} NetworkX Graph where vertices in the graph correspond to fractures and edges indicated two fractures intersect

\item[{Return type}] \leavevmode
NetworkX Graph

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{create\_graph() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{create\_graph()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.create_graph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{create\_graph}}}{\emph{self}, \emph{graph\_type}, \emph{inflow}, \emph{outflow}}{}
Header function to create a graph based on a DFN
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{graph\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Option for what graph representation of the DFN is requested. Currently supported are fracture, intersection, and bipartitie

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of inflow boundary (connect to source)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of outflow boundary (connect to target)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{G} \textendash{} Graph based on DFN

\item[{Return type}] \leavevmode
NetworkX Graph

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{create\_intersection\_graph() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{create\_intersection\_graph()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.create_intersection_graph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{create\_intersection\_graph}}}{\emph{inflow}, \emph{outflow}, \emph{intersection\_file='intersection\_list.dat'}}{}
Create a graph based on topology of network.
Edges are represented as nodes and if two intersections
are on the same fracture, there is an edge between them in the graph.

Source and Target node are added to the graph.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of inflow boundary

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of outflow boundary

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{intersection\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} File containing intersection information
File Format:
fracture 1, fracture 2, x center, y center, z center, intersection length

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{G} \textendash{} Vertices have attributes x,y,z location and length. Edges has attribute length

\item[{Return type}] \leavevmode
NetworkX Graph

\end{description}\end{quote}
\subsubsection*{Notes}

Aperture and Perm on edges can be added using add\_app and add\_perm functions

\end{fulllineitems}

\index{dump\_fractures() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{dump\_fractures()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.dump_fractures}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{dump\_fractures}}}{\emph{self}, \emph{G}, \emph{filename}}{}
Write fracture numbers assocaited with the graph G out into an ASCII file inputs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} NetworkX Graph based on the DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Output filename

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{dump\_json\_graph() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{dump\_json\_graph()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.dump_json_graph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{dump\_json\_graph}}}{\emph{self}, \emph{G}, \emph{name}}{}
Write graph out in json format
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{networkX graph}}) \textendash{} NetworkX Graph based on the DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of output file (no .json)

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}

\index{greedy\_edge\_disjoint() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{greedy\_edge\_disjoint()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.greedy_edge_disjoint}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{greedy\_edge\_disjoint}}}{\emph{self}, \emph{G}, \emph{source='s'}, \emph{target='t'}, \emph{weight='None'}, \emph{k=''}}{}
Greedy Algorithm to find edge disjoint subgraph from s to t.
See Hyman et al. 2018 SIAM MMS
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class Object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} NetworkX Graph based on the DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Starting node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Ending node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Edge weight used for finding the shortest path

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of edge disjoint paths requested

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{H} \textendash{} Subgraph of G made up of the k shortest of all edge-disjoint paths from source to target

\item[{Return type}] \leavevmode
NetworkX Graph

\end{description}\end{quote}
\subsubsection*{Notes}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Edge weights must be numerical and non-negative.

\item {} 
See Hyman et al. 2018 “Identifying Backbones in Three-Dimensional Discrete Fracture Networks: A Bipartite Graph-Based Approach” SIAM Multiscale Modeling and Simulation for more details

\end{enumerate}

\end{fulllineitems}

\index{k\_shortest\_paths() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{k\_shortest\_paths()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.k_shortest_paths}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{k\_shortest\_paths}}}{\emph{G}, \emph{k}, \emph{source}, \emph{target}, \emph{weight}}{}
Returns the k shortest paths in a graph
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX Graph}}) \textendash{} NetworkX Graph based on a DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of requested paths

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Starting node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Ending node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Edge weight used for finding the shortest path

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{paths} \textendash{} a list of lists of nodes in the k shortest paths

\item[{Return type}] \leavevmode
sets of nodes

\end{description}\end{quote}
\subsubsection*{Notes}

Edge weights must be numerical and non-negative

\end{fulllineitems}

\index{k\_shortest\_paths\_backbone() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{k\_shortest\_paths\_backbone()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.k_shortest_paths_backbone}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{k\_shortest\_paths\_backbone}}}{\emph{self}, \emph{G}, \emph{k}, \emph{source='s'}, \emph{target='t'}, \emph{weight=None}}{}
Returns the subgraph made up of the k shortest paths in a graph
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX Graph}}) \textendash{} NetworkX Graph based on a DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of requested paths

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Starting node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Ending node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Edge weight used for finding the shortest path

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{H} \textendash{} Subgraph of G made up of the k shortest paths

\item[{Return type}] \leavevmode
NetworkX Graph

\end{description}\end{quote}
\subsubsection*{Notes}

See Hyman et al. 2017 “Predictions of first passage times in sparse discrete fracture networks using graph-based reductions” Physical Review E for more details

\end{fulllineitems}

\index{load\_json\_graph() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{load\_json\_graph()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.load_json_graph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{load\_json\_graph}}}{\emph{self}, \emph{name}}{}
Read in graph from json format
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of input file (no .json)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{G} \textendash{} NetworkX Graph based on the DFN

\item[{Return type}] \leavevmode
networkX graph

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_graph() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{plot\_graph()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.plot_graph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{plot\_graph}}}{\emph{self}, \emph{G}, \emph{source='s'}, \emph{target='t'}, \emph{output\_name='dfn\_graph'}}{}
Create a png of a graph with source nodes colored blue, target red, and all over nodes black
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} NetworkX Graph based on the DFN

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Starting node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Ending node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of output file (no .png)

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Image is written to output\_name.png

\end{fulllineitems}

\index{pull\_source\_and\_target() (in module pydfnworks.dfnGraph.dfn2graph)@\spxentry{pull\_source\_and\_target()}\spxextra{in module pydfnworks.dfnGraph.dfn2graph}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.dfn2graph.pull_source_and_target}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.dfn2graph.}}\sphinxbfcode{\sphinxupquote{pull\_source\_and\_target}}}{\emph{nodes}, \emph{source='s'}, \emph{target='t'}}{}
Removes source and target from list of nodes, useful for dumping subnetworks to file for remeshing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} List of nodes in the graph

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Starting node

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{node}}) \textendash{} Ending node

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{nodes} \textendash{} List of nodes with source and target nodes removed

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}
\subsubsection*{Notes}

\end{fulllineitems}



\subsection{Graph-Based Flow and Transport}
\label{\detokenize{pydfnworks:module-pydfnworks.dfnGraph.graph_flow}}\label{\detokenize{pydfnworks:graph-based-flow-and-transport}}\index{pydfnworks.dfnGraph.graph\_flow (module)@\spxentry{pydfnworks.dfnGraph.graph\_flow}\spxextra{module}}\index{get\_laplacian\_sparse\_mat() (in module pydfnworks.dfnGraph.graph\_flow)@\spxentry{get\_laplacian\_sparse\_mat()}\spxextra{in module pydfnworks.dfnGraph.graph\_flow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_flow.get_laplacian_sparse_mat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.graph\_flow.}}\sphinxbfcode{\sphinxupquote{get\_laplacian\_sparse\_mat}}}{\emph{G}, \emph{nodelist=None}, \emph{weight=None}, \emph{dtype=None}, \emph{format='lil'}}{}
Get the matrices D, A that make up the Laplacian sparse matrix in desired sparsity format. Used to enforce boundary conditions by modifying rows of L = D - A
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} NetworkX graph equipped with weight attribute

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodelist}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of nodes of G for which laplacian is desired. Default is None in which case, all the nodes

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} For weighted Laplacian, else all weights assumed unity

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{default is None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{cooresponds to float}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{format}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} sparse matrix format, csr, csc, coo, lil\_matrix with default being lil

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{D} (\sphinxstyleemphasis{sparse 2d float array}) \textendash{} Diagonal part of Laplacian

\item {} 
\sphinxstylestrong{A} (\sphinxstyleemphasis{sparse 2d float array}) \textendash{} Adjacency matrix of graph

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{prepare\_graph\_with\_attributes() (in module pydfnworks.dfnGraph.graph\_flow)@\spxentry{prepare\_graph\_with\_attributes()}\spxextra{in module pydfnworks.dfnGraph.graph\_flow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_flow.prepare_graph_with_attributes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.graph\_flow.}}\sphinxbfcode{\sphinxupquote{prepare\_graph\_with\_attributes}}}{\emph{inflow}, \emph{outflow}}{}
Create a NetworkX graph, prepare it for flow solve by equipping edges with  attributes, renumber vertices, and tag vertices which are on inlet or outlet
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of file containing list of DFN fractures on inflow boundary

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outflow}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of file containing list of DFN fractures on outflow boundary

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{Gtilde}

\item[{Return type}] \leavevmode
NetworkX graph

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_graph\_flow() (in module pydfnworks.dfnGraph.graph\_flow)@\spxentry{run\_graph\_flow()}\spxextra{in module pydfnworks.dfnGraph.graph\_flow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_flow.run_graph_flow}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.graph\_flow.}}\sphinxbfcode{\sphinxupquote{run\_graph\_flow}}}{\emph{self}, \emph{inflow}, \emph{outflow}, \emph{Pin}, \emph{Pout}, \emph{fluid\_viscosity=0.00089}}{}
Run the graph flow portion of the workflow
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} \textendash{} DFN Class

\item[{Returns}] \leavevmode
\sphinxstylestrong{Gtilde} \textendash{} Grtilde is updated with vertex pressures, edge fluxes and travel times

\item[{Return type}] \leavevmode
NetworkX graph

\end{description}\end{quote}
\subsubsection*{Notes}

Information on individual functions in found therein

\end{fulllineitems}

\index{solve\_flow\_on\_graph() (in module pydfnworks.dfnGraph.graph\_flow)@\spxentry{solve\_flow\_on\_graph()}\spxextra{in module pydfnworks.dfnGraph.graph\_flow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_flow.solve_flow_on_graph}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.graph\_flow.}}\sphinxbfcode{\sphinxupquote{solve\_flow\_on\_graph}}}{\emph{Gtilde}, \emph{Pin}, \emph{Pout}, \emph{fluid\_viscosity=0.00089}}{}
Given a NetworkX graph prepared  for flow solve, solve for vertex pressures, and equip edges with attributes (Darcy) flux  and time of travel
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Gtilde}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Pin}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Value of pressure (in Pa) at inlet

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Pout}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Value of pressure (in Pa) at outlet

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fluid\_viscosity}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} optional, in Pa-s, default is for water

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{Gtilde} \textendash{} Gtilde is updated with vertex pressures, edge fluxes and travel times

\item[{Return type}] \leavevmode
NetworkX graph

\end{description}\end{quote}

\end{fulllineitems}

\phantomsection\label{\detokenize{pydfnworks:module-pydfnworks.dfnGraph.graph_transport}}\index{pydfnworks.dfnGraph.graph\_transport (module)@\spxentry{pydfnworks.dfnGraph.graph\_transport}\spxextra{module}}\index{Particle (class in pydfnworks.dfnGraph.graph\_transport)@\spxentry{Particle}\spxextra{class in pydfnworks.dfnGraph.graph\_transport}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_transport.Particle}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.graph\_transport.}}\sphinxbfcode{\sphinxupquote{Particle}}}
Class for graph particle tracking, instantiated for each particle


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~time}}}
Total time of travel of particle {[}s{]}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~dist}}}
total distance traveled {[}m{]}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~flag}}}
True if particle exited system, else False

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{*~frac\_seq}}}
Dictionary, contains information about fractures through which the particle went

\end{fulllineitems}

\index{add\_frac\_data() (pydfnworks.dfnGraph.graph\_transport.Particle method)@\spxentry{add\_frac\_data()}\spxextra{pydfnworks.dfnGraph.graph\_transport.Particle method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_transport.Particle.add_frac_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_frac\_data}}}{\emph{frac}, \emph{t}, \emph{L}}{}
add details of fracture through which particle traversed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{frac}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of fracture in graph

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} time in seconds

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{L}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} distance in metres

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_start\_time\_dist() (pydfnworks.dfnGraph.graph\_transport.Particle method)@\spxentry{set\_start\_time\_dist()}\spxextra{pydfnworks.dfnGraph.graph\_transport.Particle method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_transport.Particle.set_start_time_dist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_start\_time\_dist}}}{\emph{t}, \emph{L}}{}
Set initial value for travel time and distance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} time in seconds

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{L}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} distance in metres

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{track() (pydfnworks.dfnGraph.graph\_transport.Particle method)@\spxentry{track()}\spxextra{pydfnworks.dfnGraph.graph\_transport.Particle method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_transport.Particle.track}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{track}}}{\emph{Gtilde}, \emph{nbrs\_dict}}{}
track a particle from inlet vertex to outlet vertex
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Gtilde}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} graph obtained from graph\_flow

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nbrs\_dict}} (\sphinxstyleliteralemphasis{\sphinxupquote{nested dictionary}}) \textendash{} dictionary of downstream neighbours for each vertex

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_file() (pydfnworks.dfnGraph.graph\_transport.Particle method)@\spxentry{write\_file()}\spxextra{pydfnworks.dfnGraph.graph\_transport.Particle method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_transport.Particle.write_file}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write\_file}}}{\emph{partime\_file=None}, \emph{frac\_id\_file=None}}{}
write particle data to output files, if supplied
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{partime\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of file to  which the total travel times and lengths will be written for each particle, default is None

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{frac\_id\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of file to which detailed information of each particle’s travel will be written, default is None

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{create\_neighbour\_list() (in module pydfnworks.dfnGraph.graph\_transport)@\spxentry{create\_neighbour\_list()}\spxextra{in module pydfnworks.dfnGraph.graph\_transport}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_transport.create_neighbour_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.graph\_transport.}}\sphinxbfcode{\sphinxupquote{create\_neighbour\_list}}}{\emph{Gtilde}}{}
Create a list of downstream neighbour vertices for every vertex on NetworkX graph obtained after running graph\_flow
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{Gtilde}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} obtained from output of graph\_flow

\item[{Returns}] \leavevmode
\sphinxstylestrong{dict}

\item[{Return type}] \leavevmode
nested dictionary.

\end{description}\end{quote}
\subsubsection*{Notes}

dict{[}n{]}{[}‘child’{]} is a list of vertices downstream to vertex n
dict{[}n{]}{[}‘prob’{]} is a list of probabilities for choosing a downstream node for vertex n

\end{fulllineitems}

\index{run\_graph\_transport() (in module pydfnworks.dfnGraph.graph\_transport)@\spxentry{run\_graph\_transport()}\spxextra{in module pydfnworks.dfnGraph.graph\_transport}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.dfnGraph.graph_transport.run_graph_transport}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.dfnGraph.graph\_transport.}}\sphinxbfcode{\sphinxupquote{run\_graph\_transport}}}{\emph{self}, \emph{Gtilde}, \emph{nparticles}, \emph{partime\_file=None}, \emph{frac\_id\_file=None}}{}
Run  particle tracking on the given NetworkX graph
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Gtilde}} (\sphinxstyleliteralemphasis{\sphinxupquote{NetworkX graph}}) \textendash{} obtained from graph\_flow

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nparticles}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of particles

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{partime\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of file to  which the total travel times and lengths will be written for each particle, default is None

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{frac\_id\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of file to which detailed information of each particle’s travel will be written, default is None

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Information on individual functions is found therein

\end{fulllineitems}



\section{General Workflow Functions}
\label{\detokenize{pydfnworks:general-workflow-functions}}

\subsection{Print legal statement}
\label{\detokenize{pydfnworks:module-pydfnworks.general.legal}}\label{\detokenize{pydfnworks:print-legal-statement}}\index{pydfnworks.general.legal (module)@\spxentry{pydfnworks.general.legal}\spxextra{module}}\index{legal() (in module pydfnworks.general.legal)@\spxentry{legal()}\spxextra{in module pydfnworks.general.legal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.legal.legal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.general.legal.}}\sphinxbfcode{\sphinxupquote{legal}}}{\emph{self}}{}
Print the legal LANL statement for dfnWorks.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

None

\end{fulllineitems}



\subsection{Helper functions}
\label{\detokenize{pydfnworks:module-pydfnworks.general.general_functions}}\label{\detokenize{pydfnworks:helper-functions}}\index{pydfnworks.general.general\_functions (module)@\spxentry{pydfnworks.general.general\_functions}\spxextra{module}}\index{dump\_time() (in module pydfnworks.general.general\_functions)@\spxentry{dump\_time()}\spxextra{in module pydfnworks.general.general\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.general_functions.dump_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.general.general\_functions.}}\sphinxbfcode{\sphinxupquote{dump\_time}}}{\emph{self}, \emph{function\_name}, \emph{time}}{}
Write run time for a funcion to the jobname\_run\_time.txt file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{function\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of function that was timed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Run time of function in seconds

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

While this function is working, the current formulation is not robust through the entire workflow

\end{fulllineitems}

\index{print\_run\_time() (in module pydfnworks.general.general\_functions)@\spxentry{print\_run\_time()}\spxextra{in module pydfnworks.general.general\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.general_functions.print_run_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.general.general\_functions.}}\sphinxbfcode{\sphinxupquote{print\_run\_time}}}{\emph{self}}{}
Read in run times from file and and print to screen with percentages
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{self}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}) \textendash{} DFN Class

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

This will dump out all values in the run file, not just those from the most recent run

\end{fulllineitems}



\subsection{Set up run paths}
\label{\detokenize{pydfnworks:module-pydfnworks.general.paths}}\label{\detokenize{pydfnworks:set-up-run-paths}}\index{pydfnworks.general.paths (module)@\spxentry{pydfnworks.general.paths}\spxextra{module}}\index{compile\_dfn\_exe() (in module pydfnworks.general.paths)@\spxentry{compile\_dfn\_exe()}\spxextra{in module pydfnworks.general.paths}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.paths.compile_dfn_exe}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.general.paths.}}\sphinxbfcode{\sphinxupquote{compile\_dfn\_exe}}}{\emph{directory}}{}
Compile executables used in the DFN workflow including: DFNGen, DFNTrans, correct\_uge, correct\_stor, mesh\_checking. The executables LaGriT, PFLOTRAN, and FEHM are not compiled in this function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Path to dfnWorks executable

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

This function is only called if an executable is not found.

\end{fulllineitems}

\index{define\_paths() (in module pydfnworks.general.paths)@\spxentry{define\_paths()}\spxextra{in module pydfnworks.general.paths}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.paths.define_paths}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.general.paths.}}\sphinxbfcode{\sphinxupquote{define\_paths}}}{}{}
Defines enviromental variables for use in dfnWorks. The user must change these to match their workspace.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{None}} \textendash{} 

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

Enviromental variables are set to executables

\end{fulllineitems}

\index{valid() (in module pydfnworks.general.paths)@\spxentry{valid()}\spxextra{in module pydfnworks.general.paths}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pydfnworks:pydfnworks.general.paths.valid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pydfnworks.general.paths.}}\sphinxbfcode{\sphinxupquote{valid}}}{\emph{name}}{}
” Check that path is valid for a executable
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Path to file or executable

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
None

\end{description}\end{quote}
\subsubsection*{Notes}

If file is not found, program exits

\end{fulllineitems}



\chapter{dfnGen}
\label{\detokenize{dfngen:dfngen}}\label{\detokenize{dfngen:dfngen-chapter}}\label{\detokenize{dfngen::doc}}

\section{Keywords}
\label{\detokenize{dfngen:keywords}}
The following is an example input file with all keywords and explanation of each keyword.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/*=========================================================================*/}
\PYG{c+cm}{/*  Gereral Options \PYGZam{} Fracture Network Parameters:                         */}
\PYG{c+cm}{/*=========================================================================*/}

\PYG{n+nl}{stopCondition}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*  0: Stop once nPoly fractures are accepted (Defined below)}
\PYG{c+cm}{    1: Stop once all family\PYGZsq{}s p32 values are equal or greater than the}
\PYG{c+cm}{       families target p32 values (defined in stochastic family sections)}
\PYG{c+cm}{*/}

\PYG{n+nl}{nPoly}\PYG{p}{:} \PYG{l+m+mi}{400}
\PYG{c+cm}{/*  Used when stopCondition = 0 (nPoly option).}

\PYG{c+cm}{    The total number of fractures you would}
\PYG{c+cm}{    like to have in the DFN.}
\PYG{c+cm}{*/}

\PYG{n+nl}{domainSize}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Mandatory Parameter.}
\PYG{c+cm}{    Creates a domain with dimension x*y*z centered at the origin.}
\PYG{c+cm}{*/}

\PYG{n+nl}{numOfLayers}\PYG{p}{:} \PYG{l+m+mi}{2}
\PYG{c+c1}{//  Number of layers}

\PYG{n+nl}{layers}\PYG{p}{:}
\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{25}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Layers need to be listed line by line}
\PYG{c+cm}{    Format: \PYGZob{}minZ, maxZ\PYGZcb{}}

\PYG{c+cm}{    The first layer listed is layer 1, the second is layer 2, etc}
\PYG{c+cm}{    Stochastic families can be assigned to theses layers (see stochastic}
\PYG{c+cm}{    shape familiy section)}
\PYG{c+cm}{*/}

\PYG{n+nl}{h}\PYG{p}{:} \PYG{l+m+mf}{.1}
\PYG{c+cm}{/*  Minimum fracture length scale(meters).}
\PYG{c+cm}{    Any fracture with a feature, such as and intersection,}
\PYG{c+cm}{    of less than h will be rejected.}
\PYG{c+cm}{*/}


\PYG{n+nl}{radiiListIncrease}\PYG{p}{:} \PYG{l+m+mf}{0.05}
\PYG{c+cm}{/*  Percent to increase the size of the pre\PYGZhy{}generated radii lists, per family.}
\PYG{c+cm}{    Example: 0.2 will increase the size of the list by \PYGZpc{}20.}

\PYG{c+cm}{    Lists are pre\PYGZhy{}generated and are used to insert fractures from largest to}
\PYG{c+cm}{    smallest in order to help hit target distributions.}

\PYG{c+cm}{    If the accepted+rejected count of fractures is much different than the}
\PYG{c+cm}{    estimated number of fractures needed with the percentage extra added in,}
\PYG{c+cm}{    you will not get your expected distribution.}
\PYG{c+cm}{*/}



\PYG{n+nl}{removeFracturesLessThan}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*}
\PYG{c+cm}{    Options:}
\PYG{c+cm}{        0 \PYGZhy{} Ignore this option, keep all fractures.}

\PYG{c+cm}{        Size of minimum fracture radius. Fractures smaller than}
\PYG{c+cm}{        defined radius will be removed AFTER DFN generation.}

\PYG{c+cm}{        Minimum and maximum size options under fracture family}
\PYG{c+cm}{        distributions will still be used while generating the DFN.}
\PYG{c+cm}{*/}



\PYG{c+cm}{/*==========================================================================*/}
\PYG{c+cm}{/*  File Output Options:                                                    */}
\PYG{c+cm}{/*==========================================================================*/}

\PYG{c+cm}{/* An output file (radii.dat) is always generated and contains all radii of}
\PYG{c+cm}{   fractures in the domain (before and after truncation).}
\PYG{c+cm}{*/}

\PYG{n+nl}{outputAllRadii}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*  Caution: Can create very large files.}
\PYG{c+cm}{    Outputs all fractures which were generated during}
\PYG{c+cm}{    DFN generation (Accepted + Rejected).}
\PYG{c+cm}{        0: Do not output all radii file.}
\PYG{c+cm}{        1: Include file of all raddii, acepted + rejected fractures,}
\PYG{c+cm}{           in output files (radii\PYGZus{}All.dat).}
\PYG{c+cm}{*/}


\PYG{n+nl}{outputFinalRadiiPerFamily}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{c+cm}{/*  Outputs radii files after isolated fracture removal.}
\PYG{c+cm}{    One file per family.}
\PYG{c+cm}{        0: Do not create output files of radii per family}
\PYG{c+cm}{        1: Creates output files per family, containing a list}
\PYG{c+cm}{           of the family\PYGZsq{}s fracture radii that is in the final DFN}
\PYG{c+cm}{*/}

\PYG{n+nl}{outputAcceptedRadiiPerFamily}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{c+cm}{/*  Outputs radii files before isolated fracture removal.}
\PYG{c+cm}{    One file per family.}
\PYG{c+cm}{        0: Do not create output files of radii per family}
\PYG{c+cm}{        1: Creates output files per family, containing a list}
\PYG{c+cm}{           of the family\PYGZsq{}s fracture radii in the domain before isolated}
\PYG{c+cm}{           fracture removal.}
\PYG{c+cm}{*/}



\PYG{c+cm}{/*==========================================================================*/}
\PYG{c+cm}{/*  Fracture Network Parameters:                                            */}
\PYG{c+cm}{/*==========================================================================*/}

\PYG{n+nl}{tripleIntersections}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{c+cm}{/*  Accept or reject triple intersections}
\PYG{c+cm}{        0 \PYGZhy{} Off (Reject)}
\PYG{c+cm}{        1 \PYGZhy{} On  (Accept)}
\PYG{c+cm}{*/}


\PYG{n+nl}{forceLargeFractures}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{c+cm}{/*  Inserts the largest possible fracture for each defined fracture family,}
\PYG{c+cm}{    defined by the user\PYGZhy{}defined maxium radius}
\PYG{c+cm}{        0 \PYGZhy{} Off (Do not force insertion of larest fractures)}
\PYG{c+cm}{        1 \PYGZhy{} On  (Force insertion of largest fractures)}
\PYG{c+cm}{*/}

\PYG{n+nl}{printRejectReasons}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/* Useful for debugging,}
\PYG{c+cm}{   This option will print all fracture rejection reasons as they occur.}
\PYG{c+cm}{        0 \PYGZhy{} Disable}
\PYG{c+cm}{        1 \PYGZhy{} Print all rejection reasons to screen}
\PYG{c+cm}{*/}

\PYG{n+nl}{disableFram}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/* This option disables the FRAM algorithm. There will be no}
\PYG{c+cm}{   fracture rejections or fine mesh. Defaults visualizationMode to 1.}
\PYG{c+cm}{        0 \PYGZhy{} Enable  FRAM}
\PYG{c+cm}{        1 \PYGZhy{} Disable FRAM}

\PYG{c+cm}{*/}

\PYG{n+nl}{visualizationMode}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*  Used during meshing:}
\PYG{c+cm}{        0 \PYGZhy{} Creates a fine mesh, according to h parameter;}
\PYG{c+cm}{        1 \PYGZhy{} Produce only first round of triangulations. In this case no}
\PYG{c+cm}{            modeling of flow and transport is possible.}
\PYG{c+cm}{*/}

\PYG{n+nl}{seed}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*  Seed for random generator.}
\PYG{c+cm}{    Enter 0 for time based seed.}
\PYG{c+cm}{*/}

\PYG{n+nl}{domainSizeIncrease}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Size increase for inserting fracture centers outside the domain.}
\PYG{c+cm}{    Fracture will be truncated based on domainSize above.}
\PYG{c+cm}{    Increases the entire width by this ammount. So, \PYGZob{}1,1,1\PYGZcb{} will increase}
\PYG{c+cm}{    the domain by adding .5 to the +x, and subbtracting .5 to the \PYGZhy{}x, etc}
\PYG{c+cm}{*/}

\PYG{n+nl}{keepOnlyLargestCluster}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*  0 \PYGZhy{} Keep any clusters which connects the specified}
\PYG{c+cm}{        boundary faces in boundaryFaces option below}
\PYG{c+cm}{    1 \PYGZhy{} Keep only the largest cluster which connects}
\PYG{c+cm}{        the specified boundary faces in boundaryFaces option below.}

\PYG{c+cm}{    If ignoreBoundaryFaces is also set to 1, dfnGen will keep the largest}
\PYG{c+cm}{    cluster which connects at least any two sides of the domain.}
\PYG{c+cm}{*/}

\PYG{n+nl}{ignoreBoundaryFaces}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{c+cm}{/*}
\PYG{c+cm}{     0 \PYGZhy{} Use boundaryFaces option below}
\PYG{c+cm}{     1 \PYGZhy{} Ignore boundaryFaces option and keep all clusters,}
\PYG{c+cm}{         and remove fractures with no intersections}
\PYG{c+cm}{*/}

\PYG{n+nl}{boundaryFaces}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  DFN will only keep clusters with connections to}
\PYG{c+cm}{    domain boundaries which are set to 1:}

\PYG{c+cm}{    boundaryFaces[0] = +X domain boundary}
\PYG{c+cm}{    boundaryFaces[1] = \PYGZhy{}X domain boundary}
\PYG{c+cm}{    boundaryFaces[2] = +Y domain boundary}
\PYG{c+cm}{    boundaryFaces[3] = \PYGZhy{}Y domain boundary}
\PYG{c+cm}{    boundaryFaces[4] = +Z domain boundary}
\PYG{c+cm}{    boundaryFaces[5] = \PYGZhy{}Z domain boundary}

\PYG{c+cm}{    Be sure to set ignoreBoundaryFaces to 0 when}
\PYG{c+cm}{    using this feature.}
\PYG{c+cm}{*/}

\PYG{n+nl}{rejectsPerFracture}\PYG{p}{:} \PYG{l+m+mi}{350}
\PYG{c+cm}{/*  If a fracture is rejected, it will be re\PYGZhy{}translated}
\PYG{c+cm}{    to a new position this number of times.}

\PYG{c+cm}{    This helps hit distribution targets for stochastic families}
\PYG{c+cm}{    families (Set to 1 to ignore this feature)}
\PYG{c+cm}{*/}


\PYG{n+nl}{insertUserRectanglesFirst}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{c+cm}{/*  0 \PYGZhy{} User ellipses will be inserted first}
\PYG{c+cm}{    1 \PYGZhy{} User rectangles will be inserted first}
\PYG{c+cm}{*/}

\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Probability Parameters                                         */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{famProb}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{.33}\PYG{p}{,}\PYG{l+m+mf}{.33}\PYG{p}{,}\PYG{l+m+mf}{.34}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Each element is the probability of chosing a fracture from}
\PYG{c+cm}{    the element\PYGZsq{}s corresponding family to be inserted into the DFN.}

\PYG{c+cm}{    The famProb elements should add up to 1.0 (for \PYGZpc{}100).}
\PYG{c+cm}{    The probabilities are listed in order of families starting with all}
\PYG{c+cm}{    stochastic ellipses, and then all stochastic rectangles.}

\PYG{c+cm}{    For example:}
\PYG{c+cm}{    If  then there are two ellipse families, each with probabiliy .3,}
\PYG{c+cm}{    and two rectangle families, each with probabiliy .2, famProb will be:}
\PYG{c+cm}{    famProb: \PYGZob{}.3,.3,.2,.2\PYGZcb{}, famProb elements must add to 1}
\PYG{c+cm}{*/}



\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*                                                                           */}
\PYG{c+cm}{/*  Elliptical Fracture Options                                              */}
\PYG{c+cm}{/*  NOTE: Number of elements must match number of ellipse families           */}
\PYG{c+cm}{/*                                                                           */}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{nFamEll}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*  Number of ellipse families defined below.}
\PYG{c+cm}{    Having this option = 0 will ignore all rectangle family variables.}
\PYG{c+cm}{*/}

\PYG{n+nl}{eLayer}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Defines which domain, or layer, the family belings to.}
\PYG{c+cm}{    Layer 0 is the entire domain (\PYGZsq{}domainSize\PYGZsq{}).}
\PYG{c+cm}{    Layers numbered \PYGZgt{} 0 coorespond to layers defined above (see \PYGZsq{}Layers:\PYGZsq{}).}
\PYG{c+cm}{    1 corresponts to the first layer listed, 2 is the next layer listed, etc}
\PYG{c+cm}{*/}

\PYG{n+nl}{edistr}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Mandatory parameter if using statistically generated ellipses.}
\PYG{c+cm}{    Statistical distribution options:}
\PYG{c+cm}{        1 \PYGZhy{} Log\PYGZhy{}normal distribution}
\PYG{c+cm}{        2 \PYGZhy{} Truncated power law distribution}
\PYG{c+cm}{        3 \PYGZhy{} Exponential distribution}
\PYG{c+cm}{        4 \PYGZhy{} Constant}
\PYG{c+cm}{*/}

\PYG{n+nl}{ebetaDistribution}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Beta is the rotation around the polygon\PYGZsq{}s normal vector}
\PYG{c+cm}{        0 \PYGZhy{} Uniform distribution [0, 2PI)}
\PYG{c+cm}{        1 \PYGZhy{} Constant angle (specefied below by \PYGZsq{}ebeta\PYGZsq{})}
\PYG{c+cm}{*/}

\PYG{n+nl}{e\PYGZus{}p32Targets}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{.1}\PYG{p}{,}\PYG{l+m+mf}{.1}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Elliptical families target fracture intensities per family.}
\PYG{c+cm}{    When using stopCondition = 1 (defined at the top of the input file),}
\PYG{c+cm}{    families will be inserted until the families desired fracture}
\PYG{c+cm}{    intensity has been reached. Once all families desired fracture}
\PYG{c+cm}{    intensity has been met, fracture generation will complete.}
\PYG{c+cm}{*/}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/* Parameters used by all stochastic ellipse families                        */}
\PYG{c+cm}{/* Mandatory Parameters if using statistically generated ellipses            */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{easpect}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{1.1}\PYG{p}{,}\PYG{l+m+mf}{1.2}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Aspect ratio for stochastic ellipses.}

\PYG{n+nl}{enumPoints}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Number of vertices used in creating each elliptical}
\PYG{c+cm}{    fracture family. Number of elements must match number}
\PYG{c+cm}{    of ellipse families}
\PYG{c+cm}{*/}

\PYG{n+nl}{eAngleOption}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*  All angles for ellipses are in:}
\PYG{c+cm}{        0 \PYGZhy{} degrees}
\PYG{c+cm}{        1 \PYGZhy{} radians (Must use numerical value for PI)}
\PYG{c+cm}{*/}

\PYG{n+nl}{etheta}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Ellipse fracture orientation.}
\PYG{c+cm}{    The angle the normal vector makes with the z\PYGZhy{}axis,}
\PYG{c+cm}{*/}

\PYG{n+nl}{ephi}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Ellipse fracture orientation.}
\PYG{c+cm}{    The angle the projection of the normal}
\PYG{c+cm}{    onto the x\PYGZhy{}y plane makes with the x\PYGZhy{}axis}
\PYG{c+cm}{*/}

\PYG{n+nl}{ebeta}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Rotation around the fractures\PYGZsq{} normal vector.}

\PYG{n+nl}{ekappa}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Parameter for the fisher distribnShaprutions. The}
\PYG{c+cm}{    bigger, the more similar (less diverging) are the}
\PYG{c+cm}{    elliptical familiy\PYGZsq{}s normal vectors.}
\PYG{c+cm}{*/}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Ellipse Log\PYGZhy{}normal Distribution Options (edistr = 1)                     */}
\PYG{c+cm}{/*  Mandatory Parameters if using ellispes with log\PYGZhy{}normal distribution      */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{eLogMean}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Mean of the underlying normal distribution}

\PYG{n+nl}{esd}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Standard deviation of the underlying normal distribution}

\PYG{n+nl}{eLogMin}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Minimum radius}

\PYG{n+nl}{eLogMax}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Maximum radius}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Ellipse Exponential Distribution Options (edistr = 3)                    */}
\PYG{c+cm}{/*  Mandatory Parameters if using ellispes with exponential distribution     */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{eExpMean}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Mean values for exponential distributions, defined per family.}

\PYG{n+nl}{eExpMin}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Minimum radius, defined per family.}

\PYG{n+nl}{eExpMax}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// Maximum radius, defined per family.}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Ellipse Constant Size Option (edistr=4)                                  */}
\PYG{c+cm}{/*  Mandatory Parameters if using ellipses with constant size.               */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{econst}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Constant radius, defined per family.}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Ellipse Truncated Power\PYGZhy{}Law Distribution Options (edistr=2)              */}
\PYG{c+cm}{/*  Mandatory Parameters if using ellipses with power\PYGZhy{}law distributions.     */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{emin}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Minimum radius}

\PYG{n+nl}{emax}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Maximum radius}

\PYG{n+nl}{ealpha}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{2.4}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Alpha. Used in truncated power\PYGZhy{}law distribution calculations.}


\PYG{c+cm}{/*============================================================================*/}
\PYG{c+cm}{/*============================================================================*/}
\PYG{c+cm}{/*                                                                            */}
\PYG{c+cm}{/*  Rctangular Fractures Options                                              */}
\PYG{c+cm}{/*  NOTE: Number of elements must match number of rectangle families          */}
\PYG{c+cm}{/*                                                                            */}
\PYG{c+cm}{/*============================================================================*/}
\PYG{c+cm}{/*============================================================================*/}

\PYG{n+nl}{nFamRect}\PYG{p}{:} \PYG{l+m+mi}{3}
\PYG{c+cm}{/*  Number of rectangular families defined below.}
\PYG{c+cm}{    Having this option = 0 will ignore all rectangular family variables.}
\PYG{c+cm}{*/}

\PYG{n+nl}{rLayer}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Defines which domain, or layer, the family belings to.}
\PYG{c+cm}{    Layer 0 is the entire domain (\PYGZsq{}domainSize\PYGZsq{}).}
\PYG{c+cm}{    Layers numbered \PYGZgt{} 0 coorespond to layers defined above (see \PYGZsq{}Layers:\PYGZsq{}).}
\PYG{c+cm}{    1 corresponts to the first layer listed, 2 is the next layer listed, etc}
\PYG{c+cm}{*/}

\PYG{n+nl}{rdistr}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Mandatory parameter if using statistically generated rectangles.}
\PYG{c+cm}{    Rectangle statistical distribution options:}
\PYG{c+cm}{        1 \PYGZhy{} log\PYGZhy{}normal distribution}
\PYG{c+cm}{        2 \PYGZhy{} truncated power law distribution}
\PYG{c+cm}{        3 \PYGZhy{} exponential distribution}
\PYG{c+cm}{        4 \PYGZhy{} constant}
\PYG{c+cm}{*/}

\PYG{n+nl}{rbetaDistribution}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Beta is the rotation around the polygon\PYGZsq{}s normal vector}
\PYG{c+cm}{        0: Uniform distribution [0, 2PI)}
\PYG{c+cm}{        1: Constant angle (specefied below by \PYGZsq{}rbeta\PYGZsq{})}
\PYG{c+cm}{*/}

\PYG{n+nl}{r\PYGZus{}p32Targets}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{.2}\PYG{p}{,}\PYG{l+m+mf}{.2}\PYG{p}{,}\PYG{l+m+mf}{.2}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Rectangular families target fracture intensities per family.}
\PYG{c+cm}{    When using stopCondition = 1 (defined at the top of the input file),}
\PYG{c+cm}{    families will be inserted until the families desired fracture}
\PYG{c+cm}{    intensity has been reached. Once all families desired fracture}
\PYG{c+cm}{    intensity has been met, fracture generation will complete.}
\PYG{c+cm}{*/}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+c1}{//  Parameters used by all stochastic rectangle families                     */}
\PYG{c+c1}{//  Mandatory Parameters if using statistically generated rectangles         */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{raspect}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Aspect ratio for stochasic rectangles.}

\PYG{n+nl}{rAngleOption}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{c+cm}{/*  All angles for rectangles are in:}
\PYG{c+cm}{        1 \PYGZhy{} Degrees}
\PYG{c+cm}{        0 \PYGZhy{} Radians (must be numerical value, cannot use \PYGZdq{}Pi\PYGZdq{})}
\PYG{c+cm}{*/}

\PYG{n+nl}{rtheta}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{90}\PYG{p}{,}\PYG{l+m+mi}{90}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Rectangle fracture orientation.}
\PYG{c+cm}{    The angle the normal vector makes with the z\PYGZhy{}axis}
\PYG{c+cm}{*/}

\PYG{n+nl}{rphi}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{90}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Rectangle fracture orientation.}
\PYG{c+cm}{    The angle the projection of the normal}
\PYG{c+cm}{    onto the x\PYGZhy{}y plane makes with the x\PYGZhy{}axis}
\PYG{c+cm}{*/}

\PYG{n+nl}{rbeta}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Rotation around the normal vector.}

\PYG{n+nl}{rkappa}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Parameter for the fisher distribnShaprutions. The}
\PYG{c+cm}{    bigger, the more similar (less diverging) are the}
\PYG{c+cm}{    rectangular familiy\PYGZsq{}s normal vectors.}
\PYG{c+cm}{*/}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+c1}{// Rectangle Log\PYGZhy{}normal Distribution Options (rdistr = 1)                    */}
\PYG{c+c1}{// Mandatory Parameters if using rectangles with log\PYGZhy{}normal distribution     */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{rLogMean}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Mean of the underlying normal distribution}

\PYG{n+nl}{rsd}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{.3}\PYG{p}{,}\PYG{l+m+mf}{.3}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Standard deviation of the underlying normal distribution}

\PYG{n+nl}{rLogMin}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Minimum radius}

\PYG{n+nl}{rLogMax}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Maximum radius}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+c1}{// Rectangle Truncated Power\PYGZhy{}Law Distribution Options (rdistr=2)             */}
\PYG{c+c1}{// Mandatory Parameters if using rectangles with power\PYGZhy{}law distributions.    */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{rmin}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Minimum radius}

\PYG{n+nl}{rmax}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Maximum radius}

\PYG{n+nl}{ralpha}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{2.4}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Alpha. Used in truncated power\PYGZhy{}law distribution calculations.}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/* Rectangle Exponential Distribution Options (edistr=3)                     */}
\PYG{c+cm}{/* Mandatory Parameters if using rectangules with exponential distribution   */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{rExpMean}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Mean radius}

\PYG{n+nl}{rExpMin}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Minimum radius}

\PYG{n+nl}{rExpMax}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Maximum radius}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/* Rectangle Constant Size of rectangles (edistr = 4)                        */}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{n+nl}{rconst}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//  Constant radius, defined per family.}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  User\PYGZhy{}Specified Ellipses                                                  */}
\PYG{c+cm}{/*  Mandatory Parameters if using user\PYGZhy{}ellipses                              */}
\PYG{c+cm}{/*  NOTE: Number of elements must match number of user\PYGZhy{}ellipse families.     */}
\PYG{c+cm}{/*  NOTE: Only one user\PYGZhy{}ellipse is placed into the domain per defined        */}
\PYG{c+cm}{/*        user\PYGZhy{}ellipse, with possibility of being rejected                   */}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{userEllipsesOnOff}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*  0 \PYGZhy{} User ellipses off}
\PYG{c+cm}{    1 \PYGZhy{} User ellipses on}
\PYG{c+cm}{*/}

\PYG{n+nl}{UserEll\PYGZus{}Input\PYGZus{}File\PYGZus{}Path}\PYG{p}{:} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{jharrod}\PYG{o}{/}\PYG{n}{GitProjects}\PYG{o}{/}\PYG{n}{DFNGen}\PYG{o}{/}\PYG{n}{DFNC}\PYG{o}{+}\PYG{o}{+}\PYG{n}{Version}\PYG{o}{/}\PYG{n}{inputFiles}\PYG{o}{/}\PYG{n}{userPolygons}\PYG{o}{/}\PYG{n}{uEllInput}\PYG{p}{.}\PYG{n}{dat}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  User\PYGZhy{}Specified Ellipses                                                  */}
\PYG{c+cm}{/*  Mandatory Parameters if using user\PYGZhy{}ellipses                              */}
\PYG{c+cm}{/*  NOTE: Number of elements must match number of user\PYGZhy{}ellipse families.     */}
\PYG{c+cm}{/*  NOTE: Only one user\PYGZhy{}ellipse is placed into the domain per defined        */}
\PYG{c+cm}{/*        user\PYGZhy{}ellipse, with possibility of being rejected                   */}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{userEllByCoord}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{c+cm}{/*  0 \PYGZhy{} User ellipses defined by coordinates off}
\PYG{c+cm}{    1 \PYGZhy{} User ellipses defined by coordinates on}
\PYG{c+cm}{*/}

\PYG{n+nl}{EllByCoord\PYGZus{}Input\PYGZus{}File\PYGZus{}Path}\PYG{p}{:} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{jharrod}\PYG{o}{/}\PYG{n}{GitProjects}\PYG{o}{/}\PYG{n}{DFNGen}\PYG{o}{/}\PYG{n}{DFNC}\PYG{o}{+}\PYG{o}{+}\PYG{n}{Version}\PYG{o}{/}\PYG{n}{inputFiles}\PYG{o}{/}\PYG{n}{userPolygons}\PYG{o}{/}\PYG{n}{ellCoords}\PYG{p}{.}\PYG{n}{dat}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  User\PYGZhy{}Specified Rectangles                                                */}
\PYG{c+cm}{/*  NOTE: Number of elements must match number of user\PYGZhy{}ellipse families      */}
\PYG{c+cm}{/*  NOTE: Only one user\PYGZhy{}rectangle is placed into the domain per defined      */}
\PYG{c+cm}{/*        user\PYGZhy{}rectangle, with possibility of being rejected                 */}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{userRectanglesOnOff}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*  0 \PYGZhy{} User Rectangles off}
\PYG{c+cm}{    1 \PYGZhy{} User Rectangles on}
\PYG{c+cm}{*/}

\PYG{n+nl}{UserRect\PYGZus{}Input\PYGZus{}File\PYGZus{}Path}\PYG{p}{:} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{jharrod}\PYG{o}{/}\PYG{n}{GitProjects}\PYG{o}{/}\PYG{n}{DFNGen}\PYG{o}{/}\PYG{n}{DFNC}\PYG{o}{+}\PYG{o}{+}\PYG{n}{Version}\PYG{o}{/}\PYG{n}{inputFiles}\PYG{o}{/}\PYG{n}{userPolygons}\PYG{o}{/}\PYG{n}{ignoreConnTest}\PYG{p}{.}\PYG{n}{dat}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*                                                                           */}
\PYG{c+cm}{/*  User Rectangles Defined By Coordinates                                   */}
\PYG{c+cm}{/*                                                                           */}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{userRecByCoord}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c+cm}{/*  0 \PYGZhy{} User defined rectangles by coordinates off}
\PYG{c+cm}{    1 \PYGZhy{} User defined rectangles by coordinates on}
\PYG{c+cm}{*/}

\PYG{n+nl}{RectByCoord\PYGZus{}Input\PYGZus{}File\PYGZus{}Path}\PYG{p}{:} \PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{n}{GitProjects}\PYG{o}{/}\PYG{n}{DFNGen}\PYG{o}{/}\PYG{n}{DFNC}\PYG{o}{+}\PYG{o}{+}\PYG{n}{Version}\PYG{o}{/}\PYG{n}{inputFiles}\PYG{o}{/}\PYG{n}{userPolygons}\PYG{o}{/}\PYG{n}{rectCoords}\PYG{p}{.}\PYG{n}{dat}

\PYG{c+cm}{/*  WARNING: This option can cause LaGriT errors if the polygon}
\PYG{c+cm}{             vertices are not put in clockwise or counter\PYGZhy{}clockwise order.}
\PYG{c+cm}{             If errors (Usualy seg fualt during meshing in LaGriT),}
\PYG{c+cm}{             make sure the vertices are in clockwise or counter clockwise}
\PYG{c+cm}{             order. Also, coordinates must be co\PYGZhy{}planar.}
\PYG{c+cm}{*/}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Aperture Options                                                         */}
\PYG{c+cm}{/*  Mandatory Paramter                                                       */}
\PYG{c+cm}{/*  NOTE: Only one aperture type may be used at a time                       */}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{aperture}\PYG{p}{:} \PYG{l+m+mi}{3}
\PYG{c+cm}{/*  1 \PYGZhy{} Log\PYGZhy{}normal distribution}
\PYG{c+cm}{    2 \PYGZhy{} Aperture from transmissivity, first transmissivity is defined,}
\PYG{c+cm}{        and then, using a cubic law, the aperture is calculated.}
\PYG{c+cm}{    3 \PYGZhy{} Constant aperture (same aperture for all fractures)}
\PYG{c+cm}{    4 \PYGZhy{} Length Correlated Aperture}
\PYG{c+cm}{        Apertures are defined as a function of fracture size.}
\PYG{c+cm}{*/}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Log\PYGZhy{}normal Aperture Distribution Options (aperture = 1)                  */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{meanAperture}\PYG{p}{:}  \PYG{l+m+mi}{3}
\PYG{c+c1}{//  Mean value}

\PYG{n+nl}{stdAperture}\PYG{p}{:} \PYG{l+m+mf}{0.8}
\PYG{c+c1}{//  Standard deviation}


\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Aperture From Transmissivity Options (aperture = 2)                      */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{apertureFromTransmissivity}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{1.6e\PYGZhy{}9}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Transmissivity is calculated as transmissivity = F*R\PYGZca{}k,}
\PYG{c+cm}{    where F is a first element in aperturefromTransmissivity,}
\PYG{c+cm}{    k is a second element and R is a mean radius of a polygon.}
\PYG{c+cm}{    Aperture is calculated according to cubic law as}
\PYG{c+cm}{    b = (transmissivity*12)\PYGZca{}(1/3)}
\PYG{c+cm}{*/}

\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Constant Aperture Option (aperture = 3)                                  */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{constantAperture}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}5}
\PYG{c+c1}{//  Sets constant aperture for all fractures.}

\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Length Correlated Aperture (aperture = 4)                                */}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{lengthCorrelatedAperture}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{5e\PYGZhy{}5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/*  Length Correlated Aperture Option:}
\PYG{c+cm}{    Aperture is calculated by: b=F*R\PYGZca{}k,}
\PYG{c+cm}{    where F is a first element in lengthCorrelatedAperture,}
\PYG{c+cm}{    k is a second element and R is a mean radius of a polygon.}
\PYG{c+cm}{*/}

\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*  Permeability Options                                                     */}
\PYG{c+cm}{/*  Mandaatory Parameter                                                     */}
\PYG{c+cm}{/*===========================================================================*/}
\PYG{c+cm}{/*===========================================================================*/}

\PYG{n+nl}{permOption}\PYG{p}{:} \PYG{l+m+mi}{1}
\PYG{c+cm}{/*  0 \PYGZhy{} Permeability of each fracture is a function of fracture aperture,}
\PYG{c+cm}{        given by k=(b\PYGZca{}2)/12, where b is an aperture and k is permeability}
\PYG{c+cm}{    1 \PYGZhy{} Constant permeabilty for all fractures}
\PYG{c+cm}{*/}

\PYG{n+nl}{constantPermeability}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}12}  \PYG{c+c1}{//Constant permeability for all fractures}

\PYG{c+cm}{/*===========================================================================*/}
\end{sphinxVerbatim}


\chapter{dfnFlow}
\label{\detokenize{dfnflow:dfnflow}}\label{\detokenize{dfnflow:dfnflow-chapter}}\label{\detokenize{dfnflow::doc}}
\sphinxstyleemphasis{dfnFlow} involves using flow solver such as PFLOTRAN or FEHM. PFLOTRAN is recommended if a large number of fractures ( \textgreater{} O(1000)) are involved in a network. Using the function calls that are part of pydfnworks, one can create the mesh files needed to run PFLOTRAN. This will involve creating unstructured mesh file \sphinxcode{\sphinxupquote{*uge}} as well as the boundary  \sphinxcode{\sphinxupquote{*ex}} files. Please see the PFLOTRAN user manual at \sphinxurl{http://www.pflotran.org} under unstructured \sphinxstyleemphasis{explicit} format usage for further details. An example input file for PFLOTRAN is provided in the repository. Please use this as a starting point to build your input deck.

Below is a sample input file. Refer to the PFLOTRAN user manual at \sphinxurl{http://www.pflotran.org} for input parameter descriptions.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ Jan 13, 2014}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ Nataliia Makedonska, Satish Karra, LANL}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{================================================}

\PYG{n}{SIMULATION}
  \PYG{n}{SIMULATION\PYGZus{}TYPE} \PYG{n}{SUBSURFACE}
  \PYG{n}{PROCESS\PYGZus{}MODELS}
    \PYG{n}{SUBSURFACE\PYGZus{}FLOW} \PYG{n}{flow}
      \PYG{n}{MODE} \PYG{n}{RICHARDS}
    \PYG{o}{/}
  \PYG{o}{/}
\PYG{n}{END}
\PYG{n}{SUBSURFACE}

\PYG{n}{DFN}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{=========================== discretization ===================================}
\PYG{n}{GRID}
  \PYG{n}{TYPE} \PYG{n}{unstructured\PYGZus{}explicit} \PYG{n}{full\PYGZus{}mesh\PYGZus{}vol\PYGZus{}area}\PYG{p}{.}\PYG{n}{uge}
  \PYG{n}{GRAVITY} \PYG{l+m+mf}{0.}\PYG{n}{d0} \PYG{l+m+mf}{0.}\PYG{n}{d0} \PYG{l+m+mf}{0.}\PYG{n}{d0}
\PYG{n}{END}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{=========================== fluid properties =================================}
\PYG{n}{FLUID\PYGZus{}PROPERTY}
  \PYG{n}{DIFFUSION\PYGZus{}COEFFICIENT} \PYG{l+m+mf}{1.}\PYG{n}{d}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}
\PYG{n}{END}

\PYG{n}{DATASET} \PYG{n}{Permeability}
  \PYG{n}{FILENAME} \PYG{n}{dfn\PYGZus{}properties}\PYG{p}{.}\PYG{n}{h5}
\PYG{n}{END}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{=========================== material properties ==============================}
\PYG{n}{MATERIAL\PYGZus{}PROPERTY} \PYG{n}{soil1}
  \PYG{n}{ID} \PYG{l+m+mi}{1}
  \PYG{n}{POROSITY} \PYG{l+m+mf}{0.25}\PYG{n}{d0}
  \PYG{n}{TORTUOSITY} \PYG{l+m+mf}{0.5}\PYG{n}{d0}
  \PYG{n}{CHARACTERISTIC\PYGZus{}CURVES} \PYG{k}{default}
  \PYG{n}{PERMEABILITY}
    \PYG{n}{DATASET} \PYG{n}{Permeability}
  \PYG{o}{/}
\PYG{n}{END}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{=========================== characteristic curves ============================}
\PYG{n}{CHARACTERISTIC\PYGZus{}CURVES} \PYG{k}{default}
  \PYG{n}{SATURATION\PYGZus{}FUNCTION} \PYG{n}{VAN\PYGZus{}GENUCHTEN}
    \PYG{n}{M} \PYG{l+m+mf}{0.5}\PYG{n}{d0}
    \PYG{n}{ALPHA}  \PYG{l+m+mf}{1.}\PYG{n}{d}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}
    \PYG{n}{LIQUID\PYGZus{}RESIDUAL\PYGZus{}SATURATION} \PYG{l+m+mf}{0.1}\PYG{n}{d0}
    \PYG{n}{MAX\PYGZus{}CAPILLARY\PYGZus{}PRESSURE} \PYG{l+m+mf}{1.}\PYG{n}{d8}
  \PYG{o}{/}
  \PYG{n}{PERMEABILITY\PYGZus{}FUNCTION} \PYG{n}{MUALEM\PYGZus{}VG\PYGZus{}LIQ}
    \PYG{n}{M} \PYG{l+m+mf}{0.5}\PYG{n}{d0}
    \PYG{n}{LIQUID\PYGZus{}RESIDUAL\PYGZus{}SATURATION} \PYG{l+m+mf}{0.1}\PYG{n}{d0}
  \PYG{o}{/}
\PYG{n}{END}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{=========================== output options ===================================}
\PYG{n}{OUTPUT}
  \PYG{n}{TIMES} \PYG{n}{s} \PYG{l+m+mf}{0.01} \PYG{l+m+mf}{0.05} \PYG{l+m+mf}{0.1} \PYG{l+m+mf}{0.2} \PYG{l+m+mf}{0.5} \PYG{l+m+mi}{1}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{  FORMAT TECPLOT BLOCK}
  \PYG{n}{PRINT\PYGZus{}PRIMAL\PYGZus{}GRID}
  \PYG{n}{FORMAT} \PYG{n}{VTK}
  \PYG{n}{MASS\PYGZus{}FLOWRATE}
  \PYG{n}{MASS\PYGZus{}BALANCE}
  \PYG{n}{VARIABLES}
    \PYG{n}{LIQUID\PYGZus{}PRESSURE}
    \PYG{n}{PERMEABILITY}
  \PYG{o}{/}
\PYG{n}{END}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{=========================== times ============================================}
\PYG{n}{TIME}
  \PYG{n}{INITIAL\PYGZus{}TIMESTEP\PYGZus{}SIZE}  \PYG{l+m+mf}{1.}\PYG{n}{d}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8} \PYG{n}{s}
  \PYG{n}{FINAL\PYGZus{}TIME} \PYG{l+m+mf}{1.}\PYG{n}{d0} \PYG{n}{d}\PYG{o}{=}\PYG{o}{=}
  \PYG{n}{MAXIMUM\PYGZus{}TIMESTEP\PYGZus{}SIZE} \PYG{l+m+mf}{10.}\PYG{n}{d0} \PYG{n}{d}
  \PYG{n}{STEADY\PYGZus{}STATE}
\PYG{n}{END}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ REFERENCE\PYGZus{}PRESSURE 1500000.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{=========================== regions ==========================================}
\PYG{n}{REGION} \PYG{n}{All}
  \PYG{n}{COORDINATES}
    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{n}{d20} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{n}{d20} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{n}{d20}
    \PYG{l+m+mf}{1.}\PYG{n}{d20} \PYG{l+m+mf}{1.}\PYG{n}{d20} \PYG{l+m+mf}{1.}\PYG{n}{d20}
  \PYG{o}{/}
\PYG{n}{END}

\PYG{n}{REGION} \PYG{n}{inflow}
  \PYG{k+kt}{FILE} \PYG{n}{pboundary\PYGZus{}left\PYGZus{}w}\PYG{p}{.}\PYG{n}{ex}
\PYG{n}{END}

\PYG{n}{REGION} \PYG{n}{outflow}
  \PYG{k+kt}{FILE} \PYG{n}{pboundary\PYGZus{}right\PYGZus{}e}\PYG{p}{.}\PYG{n}{ex}
\PYG{n}{END}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{=========================== flow conditions ==================================}
\PYG{n}{FLOW\PYGZus{}CONDITION} \PYG{n}{initial}
  \PYG{n}{TYPE}
     \PYG{n}{PRESSURE} \PYG{n}{dirichlet}
  \PYG{o}{/}
  \PYG{n}{PRESSURE} \PYG{l+m+mf}{1.01325}\PYG{n}{d6}
\PYG{n}{END}


\PYG{n}{FLOW\PYGZus{}CONDITION} \PYG{n}{outflow}
  \PYG{n}{TYPE}
     \PYG{n}{PRESSURE} \PYG{n}{dirichlet}
  \PYG{o}{/}
  \PYG{n}{PRESSURE} \PYG{l+m+mf}{1.}\PYG{n}{d6}
\PYG{n}{END}

\PYG{n}{FLOW\PYGZus{}CONDITION} \PYG{n}{inflow}
  \PYG{n}{TYPE}
    \PYG{n}{PRESSURE} \PYG{n}{dirichlet}
  \PYG{o}{/}
  \PYG{n}{PRESSURE} \PYG{l+m+mf}{2.}\PYG{n}{d6}
\PYG{n}{END}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{=========================== condition couplers ===============================}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ initial condition}
\PYG{n}{INITIAL\PYGZus{}CONDITION}
  \PYG{n}{FLOW\PYGZus{}CONDITION} \PYG{n}{initial}
  \PYG{n}{REGION} \PYG{n}{All}
\PYG{n}{END}


\PYG{n}{BOUNDARY\PYGZus{}CONDITION} \PYG{n}{INFLOW}
  \PYG{n}{FLOW\PYGZus{}CONDITION} \PYG{n}{inflow}
  \PYG{n}{REGION} \PYG{n}{inflow}
\PYG{n}{END}

\PYG{n}{BOUNDARY\PYGZus{}CONDITION} \PYG{n}{OUTFLOW}
  \PYG{n}{FLOW\PYGZus{}CONDITION} \PYG{n}{outflow}
  \PYG{n}{REGION} \PYG{n}{outflow}
\PYG{n}{END}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{=========================== stratigraphy couplers ============================}
\PYG{n}{STRATA}
  \PYG{n}{REGION} \PYG{n}{All}
  \PYG{n}{MATERIAL} \PYG{n}{soil1}
\PYG{n}{END}

\PYG{n}{END\PYGZus{}SUBSURFACE}
\end{sphinxVerbatim}


\chapter{dfnTrans}
\label{\detokenize{dfntrans:dfntrans}}\label{\detokenize{dfntrans:dftrans-chapter}}\label{\detokenize{dfntrans::doc}}
dfnTrans is a method for resolving solute transport using control volume flow
solutions obtained from dfnFlow on the unstructured mesh generated using dfnGen.
We adopt a Lagrangian approach and represent a non-reactive conservative solute
as a collection of indivisible passive tracer particles. Particle tracking
methods (a) provide a wealth of information about the local flow field, (b) do
not suffer from numerical dispersion, which is inherent in the discretizations
of advection\textendash{}dispersion equations, and (c) allow for the computation of each
particle trajectory to be performed in an intrinsically parallel fashion if
particles are not allowed to interact with one another or the fracture network.
However, particle tracking on a DFN poses unique challenges that arise from (a)
the quality of the flow solution, (b) the unstructured mesh representation of
the DFN, and (c) the physical phenomena of interest. The flow solutions obtained
from dfnFlow are locally mass conserving, so the particle tracking method does
not suffer from the problems inherent in using Galerkin finite element codes.

dfnTrans starts from  reconstruction of local velocity field: Darcy fluxes
obtained using dfnFlow are used to reconstruct the local velocity field, which
is used for particle tracking on the DFN. Then, Lagrangian transport simulation
is used to determine pathlines through the network and simulate transport. It is
important to note that dfnTrans itself only solves for advective transport, but
effects of longitudinal dispersion and matrix diffusion, sorption, and other
retention processes are easily incorporated by post-processing particle
trajectories. The detailed description of dfnTrans algorithm and implemented
methodology is in \sphinxhref{http://link.springer.com/article/10.1007/s10596-015-9525-4}{Makedonska, N., Painter, S. L., Bui, Q. M., Gable, C. W., \&
Karra, S. (2015). Particle tracking approach for transport in three-dimensional
discrete fracture networks. Computational Geosciences, 19(5), 1123-1137.}

All source files of C code of dfnTrans are in \sphinxcode{\sphinxupquote{DFNTrans/}} directory of
dfnWorks 2.2. It compiles under linux/mac machines using \sphinxcode{\sphinxupquote{makefile}}.  In order
to run transport, first, all the parameters and paths should be set up in the
PTDFN Control file, PTDFN\_control.dat. Then, the following command should be
run:

\sphinxcode{\sphinxupquote{./DFNTrans PTDFN\_control.dat}}

The control  file sets all necessary parameters to run particle tracking in
dfnWorks.  Below is one control file example that includes a short
explanation of each parameter setting:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/***********************************************************************/}
\PYG{c+cm}{/*   CONTROL FILE FOR PARTICLE TRACKING IN DISCRETE FRACTURE NETWORK   */}
\PYG{c+cm}{/***********************************************************************/}

\PYG{c+cm}{/**********************  INPUT FILES: grid *****************************/}
\PYG{c+cm}{/**** input files with grid of DFN, mainly it\PYGZsq{}s output of DFNGen ******/}
\PYG{n+nl}{param}\PYG{p}{:} \PYG{n}{params}\PYG{p}{.}\PYG{n}{txt}
\PYG{n+nl}{poly}\PYG{p}{:} \PYG{n}{poly\PYGZus{}info}\PYG{p}{.}\PYG{n}{dat}
\PYG{n+nl}{inp}\PYG{p}{:} \PYG{n}{full\PYGZus{}mesh}\PYG{p}{.}\PYG{n}{inp}
\PYG{n+nl}{stor}\PYG{p}{:} \PYG{n}{full\PYGZus{}mesh}\PYG{p}{.}\PYG{n}{stor}
\PYG{n+nl}{boundary}\PYG{p}{:} \PYG{n}{allboundaries}\PYG{p}{.}\PYG{n}{zone}
\PYG{c+cm}{/* boundary conditions: reading the nodes that belong to in\PYGZhy{}flow and}
\PYG{c+cm}{out\PYGZhy{}flow boundaries. Should be consistent with those applied to obtain}
\PYG{c+cm}{steady state pressure solution (PFLOTRAN)   */}
\PYG{c+cm}{/*1 \PYGZhy{} top;  2 \PYGZhy{} bottom;  3 \PYGZhy{} left\PYGZus{}w;  4 \PYGZhy{} front\PYGZus{}s;  5 \PYGZhy{} right\PYGZus{}e;  6 \PYGZhy{} back\PYGZus{}n */}
\PYG{n}{in}\PYG{o}{\PYGZhy{}}\PYG{n}{flow}\PYG{o}{\PYGZhy{}}\PYG{n+nl}{boundary}\PYG{p}{:} \PYG{l+m+mi}{3}
\PYG{n}{out}\PYG{o}{\PYGZhy{}}\PYG{n}{flow}\PYG{o}{\PYGZhy{}}\PYG{n+nl}{boundary}\PYG{p}{:} \PYG{l+m+mi}{5}


\PYG{c+cm}{/**************** INPUT FILES: PFLOTRAN flow solution *******************/}
\PYG{n+nl}{PFLOTRAN}\PYG{p}{:} \PYG{n}{yes}
\PYG{n+nl}{PFLOTRAN\PYGZus{}vel}\PYG{p}{:} \PYG{n}{darcyvel}\PYG{p}{.}\PYG{n}{dat}
\PYG{n+nl}{PFLOTRAN\PYGZus{}cell}\PYG{p}{:} \PYG{n}{cellinfo}\PYG{p}{.}\PYG{n}{dat}
\PYG{n+nl}{PFLOTRAN\PYGZus{}uge}\PYG{p}{:} \PYG{n}{full\PYGZus{}mesh\PYGZus{}vol\PYGZus{}area}\PYG{p}{.}\PYG{n}{uge}

\PYG{c+cm}{/**************** INPUT FILES: FEHM flow solution ***********************/}
\PYG{c+cm}{/*currently we are using PFLOTRAN , but the code would work with FEHM, too */}
\PYG{n+nl}{FEHM}\PYG{p}{:} \PYG{n}{no}
\PYG{n+nl}{FEHM\PYGZus{}fin}\PYG{p}{:} \PYG{n}{dfn}\PYG{p}{.}\PYG{n}{fin}

\PYG{c+cm}{/************************  OUTPUT FILES  ********************************/}
\PYG{c+cm}{/* initial grid info structure output, usefull for debugging */}
\PYG{n+nl}{out\PYGZus{}grid}\PYG{p}{:} \PYG{n}{no}
\PYG{c+cm}{/* flow field: 3D Darcy velocities: output file has an each nodes position}
\PYG{c+cm}{and its Darcy velocity, reconstructed from fluxes */}
\PYG{n+nl}{out\PYGZus{}3dflow}\PYG{p}{:} \PYG{n}{no}
\PYG{c+cm}{/* out initial positions of particles into separate file */}
\PYG{n+nl}{out\PYGZus{}init}\PYG{p}{:} \PYG{n}{no}
\PYG{c+cm}{/* out particle trajectories tortuosity file, torts.dat */}
\PYG{n+nl}{out\PYGZus{}tort}\PYG{p}{:} \PYG{n}{no}

\PYG{c+cm}{/*************** output options for particles trajectories ****************/}
\PYG{c+cm}{/* output frequency is set according to trajectories curvature. We check the}
\PYG{c+cm}{curvature of particles trajectory each segment, from intersection to intersection.}
\PYG{c+cm}{If it\PYGZsq{}s like a straight line, then the output is less frequent (in case of}
\PYG{c+cm}{\PYGZdq{}out\PYGZus{}curv:yes\PYGZdq{}, if \PYGZdq{}no\PYGZdq{},  the output file will contain every time step) */}
\PYG{n+nl}{out\PYGZus{}curv}\PYG{p}{:} \PYG{n}{yes}
\PYG{c+cm}{/* output into avs file (GMV visualization, Paraview visualization) */}
\PYG{n+nl}{out\PYGZus{}avs}\PYG{p}{:} \PYG{n}{no}
\PYG{c+cm}{/* output into trajectories ascii files (veloc+posit+cell+fract+time) */}
\PYG{n+nl}{out\PYGZus{}traj}\PYG{p}{:} \PYG{n}{yes}

\PYG{c+cm}{/* temporary outputs (every time step from intersection to intersection)*/}
\PYG{c+cm}{/* use outputs to file or memory buffer. Memory buffer by default */}
\PYG{n+nl}{out\PYGZus{}filetemp}\PYG{p}{:} \PYG{n}{no}

\PYG{c+cm}{/************* output directories *************************************/}
\PYG{n+nl}{out\PYGZus{}dir}\PYG{p}{:} \PYG{n}{traj\PYGZus{}SR} \PYG{c+cm}{/* path and name of directory where all the particle}
\PYG{c+cm}{                     tracking results will be written*/}


\PYG{n+nl}{out\PYGZus{}path}\PYG{p}{:} \PYG{n}{trajectories} \PYG{c+cm}{/*name of directory where all particle}
\PYG{c+cm}{                    trajectories will be saved, in out\PYGZus{}dir path */}

\PYG{c+cm}{/* name of resultant file (in out\PYGZus{}dir path), which contains total travel time and}
\PYG{c+cm}{                final positions of particles */}
\PYG{n+nl}{out\PYGZus{}time}\PYG{p}{:} \PYG{n}{partime}



\PYG{c+cm}{/**************** PARTICLES INITIAL POSITIONS ******************************/}

\PYG{c+cm}{/*****  particles positions according to in\PYGZhy{}flow flux weight *********/}
\PYG{n+nl}{init\PYGZus{}fluxw}\PYG{p}{:} \PYG{n}{no} \PYG{c+c1}{//turn on this input option (don\PYGZsq{}t forget to turn off rest of PARTICLES INITIAL POSITIONS options)}
\PYG{n+nl}{init\PYGZus{}totalnumber}\PYG{p}{:} \PYG{l+m+mi}{10000} \PYG{c+c1}{// distance [m] between particles at inflow face for equal flux weight calculation}


\PYG{c+cm}{/****init\PYGZus{}nf: if yes \PYGZhy{} the same number of particles (init\PYGZus{}partn) will be placed}
\PYG{c+cm}{     on every boundary fracture edge on in\PYGZhy{}flow boundary,}
\PYG{c+cm}{     equidistant from each other ****/}
\PYG{n+nl}{init\PYGZus{}nf}\PYG{p}{:} \PYG{n}{yes}
\PYG{n+nl}{init\PYGZus{}partn}\PYG{p}{:} \PYG{l+m+mi}{10}

\PYG{c+cm}{/****init\PYGZus{}eqd: if yes \PYGZhy{} particles will be placed on the same distance from}
\PYG{c+cm}{     each other on all over in\PYGZhy{}flow boundary edges ***********************/}
\PYG{n+nl}{init\PYGZus{}eqd}\PYG{p}{:} \PYG{n}{no}  \PYG{c+c1}{//maximum number of particles that user expects on one boundary edge}
\PYG{n+nl}{init\PYGZus{}npart}\PYG{p}{:} \PYG{l+m+mi}{100}

\PYG{c+cm}{/*** all particles start from the same region at in\PYGZhy{}flow boundary, in a range}
\PYG{c+cm}{    \PYGZob{}in\PYGZus{}xmin, in\PYGZus{}xmax,in\PYGZus{}ymin, in\PYGZus{}ymax, in\PYGZus{}zmin, in\PYGZus{}zmax\PYGZcb{} **************/}
\PYG{n+nl}{init\PYGZus{}oneregion}\PYG{p}{:} \PYG{n}{no}
\PYG{n+nl}{in\PYGZus{}partn}\PYG{p}{:} \PYG{l+m+mi}{100000}
\PYG{n+nl}{in\PYGZus{}xmin}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{50.0}
\PYG{n+nl}{in\PYGZus{}xmax}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{50.0}
\PYG{n+nl}{in\PYGZus{}ymin}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{20.0}
\PYG{n+nl}{in\PYGZus{}ymax}\PYG{p}{:}  \PYG{l+m+mf}{20.0}
\PYG{n+nl}{in\PYGZus{}zmin}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.0}
\PYG{n+nl}{in\PYGZus{}zmax}\PYG{p}{:}  \PYG{l+m+mf}{0.0}

\PYG{c+cm}{/**** all particles are placed randomly over all fracture surface}
\PYG{c+cm}{     (not only on boundary edges!) ************************************/}
\PYG{n+nl}{init\PYGZus{}random}\PYG{p}{:} \PYG{n}{no}
\PYG{c+c1}{// total number of particles}
\PYG{n+nl}{in\PYGZus{}randpart}\PYG{p}{:} \PYG{l+m+mi}{100}

\PYG{c+cm}{/**** all particles are seed randomly over matrix,}
\PYG{c+cm}{     they will start travel in DFN from the node/cell that is closest to}
\PYG{c+cm}{     their initial position in rock matrix ***************************/}

\PYG{n+nl}{init\PYGZus{}matrix}\PYG{p}{:} \PYG{n}{no}
\PYG{c+c1}{// to obtain these files, run python script RandomPositGener.py}
\PYG{n+nl}{inm\PYGZus{}coord}\PYG{p}{:} \PYG{n}{ParticleInitCoordR}\PYG{p}{.}\PYG{n}{dat}
\PYG{n+nl}{inm\PYGZus{}nodeID}\PYG{p}{:} \PYG{n}{ClosestNodeR}\PYG{p}{.}\PYG{n}{inp}
\PYG{n+nl}{inm\PYGZus{}porosity}\PYG{p}{:} \PYG{l+m+mf}{0.02}
\PYG{n+nl}{inm\PYGZus{}diffcoeff}\PYG{p}{:} \PYG{l+m+mf}{1.0e\PYGZhy{}12}

\PYG{c+cm}{/*************** Intersection Mixing Rule **********************************/}
\PYG{c+cm}{/****streamline\PYGZus{}routing: if yes \PYGZhy{} streamline routing is the selected subgrid process}
\PYG{c+cm}{     otherwise the complete mixing rule is selected ****/}
\PYG{n+nl}{streamline\PYGZus{}routing}\PYG{p}{:} \PYG{n}{no}


\PYG{c+cm}{/************* TIME DOMAIN RANDOM WALK ******************************/}
\PYG{n+nl}{tdrw}\PYG{p}{:} \PYG{n}{no}
\PYG{n+nl}{tdrw\PYGZus{}porosity}\PYG{p}{:} \PYG{l+m+mf}{0.02}
\PYG{n+nl}{tdrw\PYGZus{}diffcoeff}\PYG{p}{:} \PYG{l+m+mf}{1.0e\PYGZhy{}11}

\PYG{c+cm}{/****************** FLOW AND FRACTURE PARAMETERS **********************/}
\PYG{n+nl}{porosity}\PYG{p}{:} \PYG{l+m+mf}{1.0} \PYG{c+c1}{// porosity}
\PYG{n+nl}{density}\PYG{p}{:} \PYG{l+m+mf}{997.73}  \PYG{c+c1}{//fluid density}
\PYG{n+nl}{satur}\PYG{p}{:} \PYG{l+m+mf}{1.0}
\PYG{n+nl}{thickness}\PYG{p}{:} \PYG{l+m+mf}{1.0} \PYG{c+c1}{//DFN aperture  (used in case of no aperture file provided)}

\PYG{c+cm}{/************************ APERTURE *********************************/}

\PYG{n+nl}{aperture}\PYG{p}{:} \PYG{n}{yes}  \PYG{c+c1}{//DFN aperture}
\PYG{n+nl}{aperture\PYGZus{}type}\PYG{p}{:} \PYG{n}{frac} \PYG{c+c1}{//aperture is giving per cell (type \PYGZdq{}cell\PYGZdq{})}
\PYG{c+c1}{//    or per fracture (type \PYGZdq{}frac\PYGZdq{})}
\PYG{c+c1}{// for now we use an aperture giving per fracture}
\PYG{n+nl}{aperture\PYGZus{}file}\PYG{p}{:} \PYG{n}{aperture}\PYG{p}{.}\PYG{n}{dat}


\PYG{c+cm}{/********************  TIME ********************************************/}
\PYG{n+nl}{timesteps}\PYG{p}{:} \PYG{l+m+mi}{2000000}
\PYG{c+c1}{//units of time (years, days, hours, minutes)}
\PYG{n+nl}{time\PYGZus{}units}\PYG{p}{:} \PYG{n}{seconds}

\PYG{c+cm}{/**** flux weighted particles*/}
\PYG{c+cm}{/**** in case of random initial positions of particles \PYGZhy{} it\PYGZsq{}s aperture weighted **/}
\PYG{n+nl}{flux\PYGZus{}weight}\PYG{p}{:} \PYG{n}{yes}
\PYG{c+cm}{/* random generator seed */}
\PYG{n+nl}{seed}\PYG{p}{:} \PYG{l+m+mi}{337799}

\PYG{c+cm}{/*********************  Control Plane/Cylinder Output ********************/}
\PYG{c+cm}{/*** virtual Control planes will be build in the direction of flow.}
\PYG{c+cm}{Once particle crosses the control plane, it\PYGZsq{}s position, velocity, time}
\PYG{c+cm}{will output to an ascii file. ****/}
\PYG{n+nl}{ControlPlane}\PYG{p}{:} \PYG{n}{yes}

\PYG{c+cm}{/* the path and directory name with all particles output files */}
\PYG{n+nl}{control\PYGZus{}out}\PYG{p}{:} \PYG{n}{outcontroldir}

\PYG{c+cm}{/* Delta Control Plane \PYGZhy{} the distance between control planes */}
\PYG{n+nl}{delta\PYGZus{}Control}\PYG{p}{:} \PYG{l+m+mi}{1}

\PYG{c+cm}{/* ControlPlane: direction of flow: x\PYGZhy{}0; y\PYGZhy{}1; z\PYGZhy{}2 */}
\PYG{n+nl}{flowdir}\PYG{p}{:} \PYG{l+m+mi}{0}


\PYG{c+cm}{/**************************************************************************/}
\PYG{o}{/}\PYG{n}{endendend}\PYG{o}{/}
\PYG{n}{END}
\end{sphinxVerbatim}


\chapter{Scripts}
\label{\detokenize{scripts:scripts}}\label{\detokenize{scripts:scripts-chapter}}\label{\detokenize{scripts::doc}}
The pydfnworks package has four Python scripts that assist with compiling, testing, and running the software. These scripts are all in the folder \sphinxcode{\sphinxupquote{dfnWorks/pydfnworks/bin/}} .


\section{fix\_paths.py: fix the paths in the tests folder}
\label{\detokenize{scripts:fix-paths-py-fix-the-paths-in-the-tests-folder}}
The tests that come with dfnWorks depend on pathnames which vary depending on where dfnWorks is installed. To fix these paths automatically, run the ‘’fix\_paths.py’’ script accordingly:

\sphinxcode{\sphinxupquote{python fix\_paths.py}}


\chapter{Output files}
\label{\detokenize{output:output-files}}\label{\detokenize{output:output-chapter}}\label{\detokenize{output::doc}}
dfnWorks outputs about a hundred different output files. This section describes the contents and purpose of each file.


\section{dfnGen}
\label{\detokenize{output:dfngen}}
\sphinxstylestrong{aperture.dat:}

\phantomsection\label{\detokenize{output:aperture-dat}}
\sphinxstylestrong{connectivity.dat:}

\phantomsection\label{\detokenize{output:connectivity-dat}}
Fracture connection list. Each row corresponds to a single fracture. The integers in that row are the fractures that fracture intersects with. These are the non-zero elements of the adjacency matrix.

\sphinxstylestrong{convert\_uge\_params.txt:}

\phantomsection\label{\detokenize{output:convert-uge-params-txt}}
Input file do conver\_uge executable.

\sphinxstylestrong{DFN\_output.txt:}

\phantomsection\label{\detokenize{output:dfn-output-txt}}
Detailed information about fracture network. Output by DFNGen.

\sphinxstylestrong{families.dat:}

\phantomsection\label{\detokenize{output:families-dat}}
Information about fracture families. Produced by DFNGen.

\sphinxstylestrong{input\_generator.dat:}

\phantomsection\label{\detokenize{output:input-generator-dat}}
Input file for DFN generator.

\sphinxstylestrong{input\_generator\_clean.dat:}

\phantomsection\label{\detokenize{output:input-generator-clean-dat}}
Abbreviated input file for DFN generator.

\sphinxstylestrong{normal\_vectors.dat:}

\phantomsection\label{\detokenize{output:normal-vectors-dat}}
Normal vector of each fracture in the network.

\sphinxstylestrong{params.txt:}

\phantomsection\label{\detokenize{output:params-txt}}
Parameter information about the fracture network used for meshing. Includes number of fractures, h, visualmode, expected number of dudded points, and x,y,z dimensions of the domain.

\sphinxstylestrong{poly\_info.dat:}

\phantomsection\label{\detokenize{output:poly-info-dat}}
Fracture information output by DFNGen. Format: Fracture Number, Family number, rotation angle for rotateln in LaGriT, x0, y0, z0, x1, y1, z1 (end points of line of rotation).

\sphinxstylestrong{user\_rects.dat:}

\phantomsection\label{\detokenize{output:user-rects-dat}}
User defined rectangle file.

\sphinxstylestrong{radii:}

\phantomsection\label{\detokenize{output:radii}}
Subdirectory containing fracture radii information.

\sphinxstylestrong{radii.dat:}

\phantomsection\label{\detokenize{output:radii-dat}}
Concatentate file of fracture radii. Contains fractures that are removed due to isolation.

\sphinxstylestrong{radii\_Final.dat:}

\phantomsection\label{\detokenize{output:radii-final-dat}}
Concatentated file of final radii in the DFN.

\sphinxstylestrong{rejections.dat:}

\phantomsection\label{\detokenize{output:rejections-dat}}
Summary of rejection reasons.

\sphinxstylestrong{rejectsPerAttempt.dat:}

\phantomsection\label{\detokenize{output:rejectsperattempt-dat}}
Number of rejections per attempted fracture.

\sphinxstylestrong{translations.dat:}

\phantomsection\label{\detokenize{output:translations-dat}}
Fracture centriods.

\sphinxstylestrong{triple\_points.dat:}

\phantomsection\label{\detokenize{output:triple-points-dat}}
x,y,z location of triple intersection points.

\sphinxstylestrong{warningFileDFNGen.txt:}

\phantomsection\label{\detokenize{output:warningfiledfngen-txt}}
Warning file output by DFNGen.

\sphinxstylestrong{intersection\_list.dat:}

\phantomsection\label{\detokenize{output:intersection-list-dat}}
List of intersections between fractures. Format is fracture1 fracture2 x y z length. Negative numbers correspond to intersections with boundaries.


\section{LaGrit}
\label{\detokenize{output:lagrit}}
\sphinxstylestrong{bound\_zones.lgi:}

\phantomsection\label{\detokenize{output:bound-zones-lgi}}
LaGriT run file to identify boundary nodes. Dumps zone files.

\sphinxstylestrong{boundary\_output.txt:}

\phantomsection\label{\detokenize{output:boundary-output-txt}}
Output file from bound\_zones.lgi.

\sphinxstylestrong{finalmesh.txt:}

\phantomsection\label{\detokenize{output:finalmesh-txt}}
Brief summary of final mesh.

\sphinxstylestrong{full\_mesh.inp:}

\phantomsection\label{\detokenize{output:full-mesh-inp}}
Full DFN mesh in AVS format.

\sphinxstylestrong{full\_mesh.lg:}

\phantomsection\label{\detokenize{output:full-mesh-lg}}
Full DFN mesh in LaGriT binary format.

\sphinxstylestrong{full\_mesh.uge:}

\phantomsection\label{\detokenize{output:full-mesh-uge}}
Full DFN mesh in UGE format. NOTE volumes are not correct in this file. This file is processed by convert\_uge to create full\_mesh\_vol\_area.uge, which has the correct volumes.

\sphinxstylestrong{full\_mesh\_viz.inp:}

\phantomsection\label{\detokenize{output:full-mesh-viz-inp}}
\sphinxstylestrong{intersections:}

\phantomsection\label{\detokenize{output:intersections}}
Directory containing intersection avs files output by the generator and used by LaGrit.

\sphinxstylestrong{lagrit\_logs:}

\phantomsection\label{\detokenize{output:lagrit-logs}}
Directory of output files from individual meshing.

\sphinxstylestrong{logx3dgen:}

\phantomsection\label{\detokenize{output:logx3dgen}}
LaGriT output.

\sphinxstylestrong{outx3dgen:}

\phantomsection\label{\detokenize{output:outx3dgen}}
LaGriT output.

\sphinxstylestrong{parameters:}

\phantomsection\label{\detokenize{output:parameters}}
Directory of parameter*.mgli files used for fracture meshing.

\sphinxstylestrong{polys:}

\phantomsection\label{\detokenize{output:polys}}
Subdirectory contiaining AVS file for polygon boundaries.

\sphinxstylestrong{tri\_fracture.stor:}

\phantomsection\label{\detokenize{output:tri-fracture-stor}}
FEHM stor file. Information about cell volume and area.

\sphinxstylestrong{user\_function.lgi:}

\phantomsection\label{\detokenize{output:user-function-lgi}}
Function used by LaGriT for meshing. Defines coarsening gradient.


\section{PFLOTRAN}
\label{\detokenize{output:pflotran}}
Fracture based aperture value for the DFN. Used to rescale volumes in full\_mesh\_vol\_area.uge.

\sphinxstylestrong{cellinfo.dat:}

\phantomsection\label{\detokenize{output:cellinfo-dat}}
Mesh information output by PFLOTRAN.

\sphinxstylestrong{dfn\_explicit-000.vtk:}

\phantomsection\label{\detokenize{output:dfn-explicit-000-vtk}}
VTK file of initial conditions of PFLOTRAN. Mesh is not included in this file.

\sphinxstylestrong{dfn\_explicit-001.vtk:}

\phantomsection\label{\detokenize{output:dfn-explicit-001-vtk}}
VTK file of steady-state solution of PFLOTRAN. Mesh is not included in this file.

\sphinxstylestrong{dfn\_explicit-mas.dat:}

\phantomsection\label{\detokenize{output:dfn-explicit-mas-dat}}
pflotran information file.

\sphinxstylestrong{dfn\_explicit.in:}

\phantomsection\label{\detokenize{output:dfn-explicit-in}}
pflotran input file.

\sphinxstylestrong{\_dfn\_explicit.out:}

\phantomsection\label{\detokenize{output:dfn-explicit-out}}
pflotran output file.

\sphinxstylestrong{dfn\_properties.h5:}

\phantomsection\label{\detokenize{output:dfn-properties-h5}}
h5 file of fracture network properties, permeability, used by pflotran.

Full DFN mesh with limited attributes in AVS format.

\sphinxstylestrong{full\_mesh\_vol\_area.uge:}

\phantomsection\label{\detokenize{output:full-mesh-vol-area-uge}}
Full DFN in uge format. Volumes and areas have been corrected.

\sphinxstylestrong{materialid.dat:}

\phantomsection\label{\detokenize{output:materialid-dat}}
Material ID (Fracture Number) for every node in the mesh.

\sphinxstylestrong{parsed\_vtk:}

\phantomsection\label{\detokenize{output:parsed-vtk}}
Directory of pflotran results.

\sphinxstylestrong{perm.dat:}

\phantomsection\label{\detokenize{output:perm-dat}}
Fracture permeabilities in FEHM format. Each fracture is listed as a zone, starting index at 7.

\sphinxstylestrong{pboundary\_back\_n.ex:}

\phantomsection\label{\detokenize{output:pboundary-back-n-ex}}
Boundary file for back of the domain used by PFLOTRAN.

\sphinxstylestrong{pboundary\_bottom.ex:}

\phantomsection\label{\detokenize{output:pboundary-bottom-ex}}
Boundary file for bottom of the domain used by PFLOTRAN.

\sphinxstylestrong{pboundary\_front\_s.ex:}

\phantomsection\label{\detokenize{output:pboundary-front-s-ex}}
Boundary file for front of the domain used by PFLOTRAN.

\sphinxstylestrong{pboundary\_left\_w.ex:}

\phantomsection\label{\detokenize{output:pboundary-left-w-ex}}
Boundary file for left side of the domain used by PFLOTRAN.

\sphinxstylestrong{pboundary\_right\_e.ex:}

\phantomsection\label{\detokenize{output:pboundary-right-e-ex}}
Boundary file for right of the domain used by PFLOTRAN.

\sphinxstylestrong{pboundary\_top.ex:}

\phantomsection\label{\detokenize{output:pboundary-top-ex}}
Boundary file for top of the domain used by PFLOTRAN.


\section{dfnTrans}
\label{\detokenize{output:dfntrans}}
\sphinxstylestrong{allboundaries.zone:}

\phantomsection\label{\detokenize{output:allboundaries-zone}}
Concatenated file of all zone files.

\sphinxstylestrong{darcyvel.dat:}

\phantomsection\label{\detokenize{output:darcyvel-dat}}
Concatenated file of darcy velocities output by PFLOTRAN.

\sphinxstylestrong{dfnTrans\_output\_dir:}

\phantomsection\label{\detokenize{output:dfntrans-output-dir}}
Outpur directory from DFNTrans. Particle travel times, trajectories, and reconstructed Velocities are in this directory.

\sphinxstylestrong{PTDFN\_control.dat:}

\phantomsection\label{\detokenize{output:ptdfn-control-dat}}
Input file for DFNTrans.

\sphinxstylestrong{pboundary\_back\_n.zone:}

\phantomsection\label{\detokenize{output:pboundary-back-s-zone}}
Boundary zone file for the back of the domain. Normal vector (0,1,0) +- pi/2

\sphinxstylestrong{pboundary\_bottom.zone:}

\phantomsection\label{\detokenize{output:pboundary-bottom-zone}}
Boundary zone file for the bottom of the domain. Normal vector (0,0,-1) +- pi/2

\sphinxstylestrong{pboundary\_front\_s.zone:}

\phantomsection\label{\detokenize{output:pboundary-front-n-zone}}
Boundary zone file for the front of the domain. Normal vector (0,-1,0) +- pi/2

\sphinxstylestrong{pboundary\_left\_w.zone:}

\phantomsection\label{\detokenize{output:pboundary-left-w-zone}}
Boundary zone file for the left side of the domain. Normal vector (-1,0,0) +- pi/2

\sphinxstylestrong{pboundary\_right\_e.zone:}

\phantomsection\label{\detokenize{output:pboundary-right-e-zone}}
Boundary zone file for the bottom of the domain. Normal  vector (1,0,0) +- pi/2

\sphinxstylestrong{pboundary\_top.zone:}

\phantomsection\label{\detokenize{output:pboundary-top-zone}}
Boundary zone file for the top of the domain. Normal vector (0,0,1) +- pi/2



\renewcommand{\indexname}{Index}
\printindex
\end{document}